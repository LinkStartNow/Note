# 基础理论

进程作为操作系统的基本调度单位，占用系统资源（如CPU、内存）完成特定的任务，所以说进程是操作系统的标准执行单元

## 进程与程序的区别

程序是静态资源，存储于电脑磁盘中（disk磁盘资源）

程序执行后会创建进程，负责完成功能，进程是程序启动后的结果，是程序的动态表现（CPU、内存、磁盘）

## 共享访问

将硬件资源CPU、内存、缓存、硬盘等进行共享，多进程可以同时访问使用这些资源，实现硬件利用最大化，最终诞生了多任务操作系统，即在一台设备商可以同时执行多个任务（Process进程），最好的利用硬件资源

### CPU共享

采用分时复用原则（可以将CPU的执行时间切割为若干时间片，时间片分发给乧进程，让多个进程可以交替轮转使用CPU）

### 内存共享

内存资源是可以被多个进程访问和共享的，不会给进程分配固定占用的内存，这样会影响内存的重用性

电脑中的寄存器是多进程共享使用的，如果一个进程未使用完毕，另一个进程访问同一个寄存器就会覆写，导致运算异常或者结果异常

如果一个单位可以按分时复用原则使用CPU，并且可以保存恢复自己的处理器现场，那么这个单位就是一个合格的调度单位

进程的时间片耗尽会触发**软件中断**，用来保护处理器现场（进程切换时将运算过程/寄存器数据存在**进程的内核栈中**）

*该内存栈由PCB中的内存*

随后在轮到该进程时，会恢复处理器现场，将存储的运算数据，恢复到各个寄存器中，保证进程正常向下执行

## 进程的生存环境

一般情况下，操作系统会给一个进程分配4g的内存空间，其中0-3g为用户层，3-4g为内核层（系统层）

这4g其实是指虚拟内存，可以当做真实的内存来使用，使用的时候实际上是对应映射到物理内存中。**占用的物理内存远比虚拟内存中的地址小的多**

内存管理系统中有**虚拟内存映射表**，记录映射关系

### 内核层

用来存储进程信息

主要用来存储进程控制块（PCB），其中包含了所有进程相关的信息（例如PID），**只有操作系统有访问权限**

内核层内存是共享内存，多个进程可以共享同一块内存，**因为内核层只有操作系统才有访问权限，所以不怕被用户误修改**

### 用户层

用来存储进程的功能与逻辑

**注意：每个进程都拥有独立的用户空间，不允许共享，共享会产生访问异常**

我们从**高地址到低地址**来说明对应的内容：

- 命令行参数与环境变量：
	- 比如写c语言程序时的`main(int argc, char* argv[])`，后面的`argv`就是命令行参数
	- 环境变量就是用env查看的那个环境变量
- 进程栈：大概也许就是栈区空间吧
- Library库：需要有执行权限，进程运行的时候，那些函数功能的实现都保存在库中
- 堆：堆区空间
- BSS：未初始化的全局资源
- DATA：已初始化的全局资源
- TEXT：代码段
- NULL

### 页

操作系统分配资源的时候实际上并不是以字节为单位分配的，而是以页为单位分配的，大多数操作系统一页等于4096字节（4K）

接下来一个例子：

让程序员开发一段代码，申请8192个字节的内存

1. ```c
	malloc(3000);
	malloc(5192);
	```

2. ```c
	malloc(8192)
	```

> 其中第一种写法的实现过程是这样的：
>
> 首先申请了3000字节内存，操作系统会先分配一页，然后锁定部分访问权限，保证分配的是3000字节
>
> 然后检查页面的使用情况，再分配一个页面

> 第二种写法：
>
> 操作系统直接分配了两页的内存

#### 页的权限

每个页都有4重权限：

1. PROT_READ：只读
2. PROT_WRITE：只写
3. PROT_EXEC：执行
4. PROT_NONE：无权限

#### 虚拟内存间接寻页

一页有4096字节，一个指针占用4个字节，于是可以分出1024个指针，也就是能指向1024个页面，这就是一级间接寻页

以此类推，三级间接寻页最高的寻址范围为GB，32位系统最高支持**三级间接寻页**

64位系统就支持最大四级寻页，寻址范围为TB

**注意：32位操作系统的每个进程会分配4GB内存，是因为32位系统有32根地址线**

## 进程状态

- 就绪态：进程处于就绪队列中，随时等待被分配时间片，然后运行
- R 运行态：进程正在运行
- T 挂起态：进程运行的过程中被挂起，交换到了外存，不会被干扰中断
- S 睡眠态：进程还在内存中，可以被干扰中断
- Orphan 孤儿态
- Zombie 僵尸太
- 终止态

### 睡眠态与挂起态的区别

挂起态进程由于被交换到了外存，于是只能被唤醒操作唤醒，而无法被其他方式中断

睡眠态进程还在内存中，所以可以被强制中断

### 状态转换

- 只有就绪态才能和运行态互相转换，其他状态都不能直接到运行态
- 运行态可以变成其他任何状态
- 任何状态都可以直接变成终止态
- 挂起态和睡眠态只能先转换到就绪态才能在之后变成运行态

## 用户层与内核层

用户层与内核层指的是不同访问级别的CPU，系统调用引发的权限转换其实就是CPU权限切换

每当执行一次系统函数都会触发一次系统调用System_call

`printf("hello"); // 用户层接口，系统提供的API函数，开发者可以调用这些函数完成一些特定的任务，例如将数据显示在显示器中`

调用完该函数后，系统调用触发权限转换，由用户层转换到了内核层

`System_print("hello")`执行系统层函数

随后又转换到了驱动层

`hd_printf("hello")`调用了驱动层函数

### 三种访问可以触发层级转换：

1. 系统调用，调用系统函数
2. 软件中断（int 0x80），时间片耗尽触发软中断
3. 异常触发层级转换

# 进程原语

Linux操作系统提供的用于进程开发的一系列函数接口 process_api

## fork

`pid_t fork(void);`返回值为`pid_t`

一般父进程可以通过fork函数创建一个子进程

父进程和子进程之间存在继承机制，任务或数据可以继承给子进程

**注意：子进程并不会执行fork方法，不然就一直不断创建了**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


int main() {
        pid_t pid;
        pid = fork(); // 子进程未执行fork

        printf("printf 01...\n");
        printf("printf 02...\n");
        while (1);

        return 0;
}
```

> 输出了4个printf

### 返回值

- 最终在父进程中的fork收到的返回值是创建的子进程的pid
- 而在子进程中收到的返回值是0
- 如果创建失败则会返回-1

### fork趣谈

**注意：子进程并不会从main函数开头开始执行，而是会从创建它的那个fork开始执行（此时fork已经执行完，子进程结束fork继续往下走）**

#### fork细分

其实fork函数的功能是交给操作系统去实现的，具体就是运行了`CREATE`方法创建了进程，然后运行了`CLONE`方法进行了复制

> 复制的情况为：PCB部分可以共享的内容继承给子进程，子进程再独立生成一部分
>
> 用户空间部分参照发展史

实际上父子进程都要执行fork函数，每个进程执行一部分

- 父进程执行了创建与拷贝，最终创建生成的pid也就返回给了父进程
- 子进程最后就收个尾，也就是接收到了return 0，**这也就是为啥子进程获得的pid为0的原因了**

#### fork发展史

**注意：我们目前用的就是第三版fork**

- 第一版 fork函数

	> 采用完全拷贝的策略，当父进程创建子进程后，利用clone完成拷贝，把父进程所有用户空间数据拷贝一份给子进程
	>
	> *缺点：如果子进程无需使用这些拷贝过来的资源，那么父进程的拷贝操作毫无意义，拷贝开销成为了一种资源浪费*

- 第二版 vfork函数

	> vfork函数只完成子进程的创建以及PCB的拷贝与生成，但是不会向子进程复制用户空间，这意味着用vfork创建的子进程是无法执行的
	>
	> *缺点：因为不拷贝用户空间，所以需要拷贝继承的用户无法使用此函数。通常`vfork` + `execl`两个函数配合使用*

- 第三版 fork函数

	*特点：读时共享，写时复制*

	> 读时共享：当父进程创建子进程后，建立映射，可以让子进程通过映射内存访问父进程资源，无需拷贝
	>
	> 写时复制：当子进程访问映射内存时，触发写复制，父进程将子进程访问的部分数据拷贝给子进程
	>
	> **注意：写复制操作对父子进程都有效，只要修改映射，都会触发复制**

#### 案例分析

```c
#include <stdio.h>
#include <unistd.h>

int main() {
        int i = 0;
        pid_t pid;
        for (; i < 3; ++i) {
                fork();
        }
        printf("pid = %d\n", getpid());
        return 0;
}
```

最终总共创建了7个进程，包括主进程的话总共8个进程

> 说明：
>
> 以主进程创建第一个子进程为例，创建的时候，子进程的用户区是空的，啥内容都没有，然后父进程的for循环进入下一轮，i发生变动，触发了写时复制，将变动前的i值（0）复制给了进程1
>
> 然后，现在进程1内除了这个i啥都没有，于是要访问父进程的程序，触发读时共享，此时跑的for循环是父进程的，其中用的i也是父进程映射区内的，而父进程此时的i已经变成了1，所以子进程1的for循环从i等于1开始跑，也就是fork了两个新的子进程

> 另一个理解版本：
>
> 实际上可以理解为：父进程创建第一个子进程的时候把i = 0赋值给了子进程1，然后此时子进程刚开始运行就从该fork后开始运行，当前循环结束，i + 1，然后跑两遍退出循环，也就是创建了两个进程

### 工作区

这在程序中并不会自动约束，纯靠程序员手动添加限制

*要求：子进程不允许踏出自己的工作区*：

1. 子进程要永远执行于自己的工作区
2. 子进程执行完毕，立即结束，不允许子进程执行父进程的代码

## execl

用于进程重载，实际上就是把某个进程的0-3g用户空间的内容拷贝过来

我们都知道，第三代fork创建的子进程自身的用户空间时空的，执行的所有内容都得去看父进程的映射区，然而调用`execl`方法会将指定进程的用户区内容拷贝过来，也就是该子进程能实现那个进程一模一样的功能，自己的用户区被填充后也就不会再去看父进程的映射区了，**所以，如果要让子进程执行自定义的代码，一定要在fork之后的execl之前执行**

### 参数

1. 指令路径
2. 指令名
3. 指令参数
4. NULL

**注意NULL是一定要加的，不然就不知道参数什么时候结束**

子进程调用`execl`时本质上就是操作系统根据对应路径与命令预启动了那个进程（同样也创建了PCB与用户空间，是个完整的进程），然后将该进程的用户空间赋值到子进程中

**注意：无论子进程如何重载，功能如何变化，亲缘关系都是不会变的，父子关系依旧在**

### 实践

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main() {
	pid_t pid;
	pid = fork();
	if (pid) {
		printf("father running...\n");
	}
	else if (pid == 0) {
		printf("son running...\n");
		execl("/bin/date", "date", NULL);
		printf("hello world\n");
		exit(0);
	}
	else {
		perror("fork fail");
	}
	return 0;
}
```

> 其中前面一个路径可以调用`which date`指令查出`date`指令的存储位置。
>
> 然后`date`也就是argv[0]，由于该指令无需传入其他参数，于是到这里就结束了，用NULL收尾
>
> 最终子进程实现的功能也就是指令：
>
> ```bash
> date
> ```

## wait

**注意：调用一次，回收一个僵尸进程，如果有多个进程需要循环调用**

### 背景

在子进程`exit`后，操作系统并未删除它的PCB，这样的“躯壳”仍然占用着内存资源，他们便被称为**僵尸进程**，这个状态也就是**僵尸态**，他们占用着资源导致其他的进程不能被很好的创建，能“杀死”他们的**只有创建他们的父进程**

---

### 返回值

返回一个`pid_t`类型的值：

- \>0：也就是杀死的进程的pid
- <0：杀死失败

**注意：一般情况下不会杀死失败，除非调用者正在杀死一个不存在的进程**

---

### 参数

传入的参数是`int* status`，这个int指针传入进去，用于接收退出的状态，后续可以通过这个状态查询进程被结束的原因（也就是验尸）

**注意：该函数是阻塞函数，如果子进程并没有进入僵尸态，则会一直等待某个子进程`exit`**

### 实践

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void work() {
	printf("father working...\n");
}

int main() {
	printf("hello world\n");
	int i = 0;
	pid_t pid;
	for (; i < 5; ++i) {
		pid = fork();
		if(!pid) break;
	}
	if (pid > 0) {
		pid_t zpid;
		while ((zpid = wait(NULL)) != -1) {
			if (zpid > 0) printf("father kill the child:%d\n", zpid);
			else work();
			sleep(1);
		}
	}
	else if (pid == 0) {
		sleep(5 * i);
		printf("child pid = %d died\n", getpid());
		exit(i * 5);
	}
	else {
		perror("fork fail");
	}
	while (1) sleep(1);
	return 0;
}
```

> 由于是阻塞的，于是父进程大部分时间都会停留在wait那里，然后每次返回的pid都是>0的，于是根本不会去执行work

## waitpid

实际上就是`wait`方法的扩展

**注意：`waitpid`是支持非阻塞的**

### 返回值

和`wait`一样，也是返回一个`pid_t`类型的值：

- \>0：子进程的`pid`，也就是被回收的子进程的`pid`

- 0：表示非阻塞返回

	我们都知道这个`waitpid`是支持非阻塞的，所以每次如果存在进程在运行还未变成僵尸则会返回0

- -1：回收失败

### 参数

`waitpid(pid_t pid, int* status, WNOHANG)`

- `pid`，这里`pid`有多重取值，我们分别讨论一下：
	- \>0：指定进程的`pid`，回收指定的进程
	- -1：回收任意子进程
	- 0：同组回收，表示回收当前进程同组的所有子进程
	- <-1：例如-3000,表示回收进程组id为3000的其中的所有子进程，实现跨组回收
- `status`：和`wait`中的一样，用来存储结束状态
- `WNOHANG`：这个指使用非阻塞方式

### 实践

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void work() {
	printf("father working...\n");
}

int main() {
	printf("hello world\n");
	int i = 0;
	pid_t pid;
	for (; i < 5; ++i) {
		pid = fork();
		if(!pid) break;
	}
	if (pid > 0) {
		pid_t zpid;
		while ((zpid = waitpid(-1, NULL, WNOHANG)) != -1) {
			if (zpid > 0) printf("father kill the child:%d\n", zpid);
			else work();
			sleep(1);
		}
	}
	else if (pid == 0) {
		sleep(5 * i);
		printf("child pid = %d died\n", getpid());
		exit(i * 5);
	}
	else {
		perror("fork fail");
	}
	while (1) sleep(1);
	return 0;
}
```

> 由于采用的是非阻塞，于是如果还有子进程正在睡眠没有变成僵尸，那么就会返回0，于是主进程就会先去work，然后回头继续检查

### Status校验

- 正常退出：return 0 或者exit，代码按照运行逻辑，执行到退出执行导致进程退出，属于正常退出范畴
- 异常退出：进程未执行完毕，被其他进程杀死，进程执行异常，被系统杀死

这里介绍几个常用方法：

1. `WIFEXITED(status)`：判断子进程是否正常退出，如果正常退出，返回1，否则返回0
2. `WIFSIGNALED(status)`：检测子进程是否被信号杀死（异常退出），如果是则返回1
3. `WEXITSTATUS(status)`：获得返回码，像`return 0`就可以收到0，`exit(233)`就可以收到233
4. `WTERMSIG(status)`：获得信号码，例如如果是被`kill -15 pid`杀死的，则会返回15

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main() {
	pid_t pid;
	int i = 0;
	for (; i < 2; ++i) {
		pid = fork();
		if (!pid) break;
	}
	if (pid > 0) {
		pid_t zpid;
		int status;
		while ((zpid = waitpid(-1, &status, WNOHANG)) != -1) {
			if (zpid > 0) {
				if (WIFEXITED(status)) {
					printf("child pid = %d, exit or return %d\n", zpid, WEXITSTATUS(status));
				}
				else if (WIFSIGNALED(status)) {
					printf("child pid = %d, signal %d\n", zpid, WTERMSIG(status));
				}
			}
			sleep(1);
		}
	}
	else if (pid == 0) {
		if (i == 0) {
			printf("child %d\n", getpid());
			exit(16);
		}
		else {
			printf("child %d\n", getpid());
			while (1) {
				printf("child %d\n", getpid());
				sleep(1);
			}
		}
	}
	else {
		perror("fork fail");
		exit(0);
	}
	return 0;
}
```



