# 某些机制

## ACK机制

应答机制，就是利用ack判断是否收到，详情略

## 超时重传

发送方在发送出数据后开启定时器，如果在一定时间内未收到确认包，则会重发一遍

如果是因为确认包丢失导致的超时，则重发的数据包会被丢弃，因为已经被处理过了

# 三次握手

客户端作为主动方，服务端作为被动方

刚开始，客户端和服务端都处于CLOSE状态，服务端主动监听某个端口，处于LISTEN状态

接下来开始握手：

1. 客户端使用connect主动发起连接，SYN置1，因为之前没有通讯，所有这个序列号seq是随机的（暂且定为x），之后客户端处于SYN-SEND状态

2. 服务端收到发起的连接，需要应答收到的SYN同时建立连接

	用于回复：ACK置1，ack = x + 1

	建立连接：SYN置1，seq = y（随机数）

	随后服务端处于SYN-REVD状态

3. 客户端收到后，再发送一个确认收到的回复，也就是ack = y + 1，seq = x + 1，ACK置1

	之后客户端处于ESTABLISHED状态（已确立），因为一收一发都成功了，connect返回

4. 服务端收到ACK后，处于ESTABLISHED状态，因为一收一发也成功了，accept也返回了

# 四次挥手

客户端作为主动方，服务端作为被动方

1. 主动方打算关闭连接，调用close函数后，会发送一个FIN置1的报文，也就是FIN报文，之后主动方进入FIN_WAIT_1状态，数据报中的seq = u，ack = v + 1都是承接直接数据传输下的

2. 被动方收到该报文后，就回复ACK应答报文，接着被动方进入CLOSED_WAIT状态，seq = v + 1，ack = u + 1，ACK置1。**注意：此时被动方还不能断开连接，因为可能还有一些数据在路上，还有一些数据收到未处理**

3. 主动方收到应答，进入FIN_WAIT_2状态

4. 被动方处理完数据，向主动方发送FIN报文，之后被动方进入LAST_ACK状态。seq = v + 2是继续被动方上一次发的seq = v + 1,**ack = u + 1说明应答的是seq = u的消息**，ACK置1，FIN置1

	**注意：第二次被动方发完后，这条是被动方连续发送的第二条，其中主动方没有发送与断开相关的任何数据报**

5. 主动方收到FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态。seq = u + 1，ack = v + 3说明回应的是刚刚被动方发的报文，ACK置1

6. 被动方收到了ACK应答报文后，进入了CLOSED状态，被动方的连接关闭

7. 主动方在经过两倍MSL一段时间后，自动进入了CLOSED状态，主动方连接关闭

## 为什么TIME_WAIT状态等待2MSL

MSL是报文最长生存时间，超过这个时间报文将被丢弃，2MSL可以保证数据报一去一回，防止四次挥手的第四次数据包丢失后无法重传数据报，导致无法重传。

如果第四个包丢了，那么1个MSL后，服务器会重新给客户端发送一个FIN包，2倍的MSL时间足够接收到服务器重传FIN包

# TCP/IP协议相关知识

## RTT

即Round-Trip Time，往返时延

发送方发出信息开始，到收到接收端的确认

由三个部分决定：

1. 链路传播时间
2. 末端系统的处理时间
3. 路由器的缓存中的排队和处理时间

前两个部分作为一个TCP连接相对固定，最后一个会随着网络的拥塞程度的变化而变化

## RTO

Retransmission Timeout，超时重传时间

一般RTO略大于TCP报文段平均往返时延RTT，一般RTO = 2RTT

若超过了RTO还未收到确认信息，则必须重传此报文段

## 滑动窗口

窗口大小就是指无序等待确认应答，而可以继续发送数据的最大值，接收方也可以对此做统一的应答

例如：假如发送端的窗口大小为4000，那么在发送完1000的数据后，不用等到对方的ack到达，而可以立即继续发送剩下<=3000的数据，接收方等到收到这4000的数据后，统一回复一个ack = 4001

每次接收端的回复中都会带有自己窗口的剩余空间，这个值会被用来更新发送方的窗口，防止发送过来的太多，装不下

**注意：三次握手的第二个握手信息中就包含了服务端的窗口大小**

## 流量控制

流量控制就是通过滑动窗口实现的

每次接收方都会发回现在还剩余的空间大小，若某一时刻接收方比较忙，数据处理的比较慢，窗口被塞满了，那么发送0的大小过去，发送方就会被阻塞，不会再发消息过来了

## 粘包问题

UDP协议的每个数据包都不可拆分，发多少接多少，接不了就扔掉

由于TCP是基于字节流的传输，发送过去一长串的0101的数据文件之间都粘在了一起，很难分清当前的100字节是一个数据包还是两个数据包

解决方案：

1. 设置标志位
	1. 在开头设置标志位，缺点：若只有一个数据包，则无法判断结束
	2. 在结尾设置标志位，缺点：若数据包内容和标志位重复，则会导致拆包失败
2. 固定包大小，缺点：若数据包比较小就会造成浪费，若数据包比较大就会发送失败
3. 先发送包大小，再发送包。缺点：要多发一个包
4. 短连接，缺点：耗费更多时间，浪费更多资源

## 心跳机制

定时发送一个自定义的结构体（心跳包），让对方知道自己还活着（连接还正常）

用于长连接，并且很长一段时间都没有数据往来

## Nagle算法

为了尽可能利用网络带宽，TCP总是尽可能的发送足够大的数据（尽量接近与MSS）。Nagle算法就是为了尽可能的发送大块数据

规则：

1. 如果包长度达到MSS，则发送
2. 如果包含有FIN，则发送
3. 设置了TCP_NODELAY选项，则发送
4. 未设置TCP_CORK选项，若发送出去的所有小的数据包（小于MSS）均被确认，则允许发送
5. 上述条件都未满足，但发生了超时（一般为200ms），则立即发送

**注意：Nagle算法默认打开，但如果是一些需要小数据交互的场景，则需要关闭**

```c++
int value = 1;
setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char*)&value, sizeof(int));
```

## 拥塞控制

拥塞控制是一个全局性的过程，和流量控制不同，流量控制是点对点的通信量的控制

发送方会维持一个叫做**拥塞窗口cwnd（congestion window）的状态变量**。其大小取决于网络的拥塞程度，并且动态变化，发送方让自己的发送窗口等于拥塞窗口

### 拥塞控制算法

这里介绍四种拥塞控制的算法：

> 为了防止cwnd增长过大引起网络拥塞，还需要设置一个**慢开始门限ssthresh状态变量**
>
> - 当cwnd < ssthresh时：用慢开始
> - cwnd > ssthresh时：拥塞避免
> - 相等时：随意

1. 慢开始：每经过一个传入轮次，拥塞窗口cwnd就会翻倍

2. 拥塞避免：每经过一个往返时间RTT就把**cwnd+1，而不是加倍**

3. 快重传：发送方只要一连收到三个重复确认就会立即重传对方未收到的报文段，而不用等待设置的重传计时器时间到期

4. 快恢复：当发送方连续收到三个重复的确认时，就会执行“乘法减小”算法：

	先将门限变为当前cwnd的一半，然后cwnd变成门限+3，然后执行拥塞避免算法

> 无论是在慢开始阶段还是拥塞避免阶段，只要出现拥塞慢开始门限都会变成出现拥塞时**cwnd的一半**，然后把**cwnd变为1**，执行**慢开始算法**

# TCP总结

## 为什么可靠

1. 三次握手和四次挥手
2. 重传和确认的机制
3. 合理的分段
4. 校验重新排序
5. 滑动窗口-流量控制
6. 拥塞窗口-拥塞控制

**注意：由于TCP是一对一连接通讯的，所以一般正常情况下是不能发送广播的**

