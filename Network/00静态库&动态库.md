# 静态库&动态库

我们平时使用的各种函数（如`printf`等）都是别人写好的，我们进行导入使用。和之前游戏项目细分文件夹分别写头文件和源文件实现一样。库的调用也差不多，而且在多人合作的大项目中效果显著

## 静态库

### 编写静态库项目

首先为了得到静态库文件（`.lib`），在创建项目时选择创建静态库项目，这样最终能成功生成静态库文件

一般会默认有两个头文件（`pch.h`）（`framework.h`）和对应的源文件（`.cpp`），`framework.h`的头文件时给`pch.h`来使用的，不用修改

自己要写方法什么的就声明在`pch.h`中，然后在对应的源文件中实现即可

### 调用

写静态库就是为了提供给其他项目使用，为了方便，与后期的使用稳定，我们通常会把静态库（`.lib`）文件和项目文件放在同一路径下（也可以单独多创建一个文件夹）

然后我们就可以通过相对路径来导入依赖库（虽然绝对路径也可以，但是用绝对路径不利于后期文件的移动，而且也失去了文件放在统一路径下的意义）

```c++
// 导入依赖库
#pragma comment(lib, "./lib/Test00.lib")
```

同样的，我们也需要把之前静态库项目中的头文件加入到当前项目的同一路径下（也可以多创建一个文件夹）

**注意：两个头文件都要转移，即（`pch.h`）（`framework.h`）都要转移**

然后正常包含对应的头文件

```c++
// 包含对应的头文件
#include "include/pch.h"
```

---

## 动态库

### 编写动态库项目

创建项目时选择动态链接库

同样也是两个头文件

**注意：声明方法与静态库不同**

在动态库中声明提供给外部的函数是需要加上东西的，如下：

```c++
// 声明导出，这种函数才能被调用
_declspec(dllexport) int sub(int, int);
```

在实现的时候不用加，正常实现的格式就行，如下：

```c++
int sub(int a, int b)
{
	return a - b;
}
```

### 调用

动态库项目也会生成`.lib`文件，所以也要像静态库一样把`.lib`文件和头文件加入到对应的路径下

然后也和静态库一样要导入依赖库

```c++
// 导入依赖库
#pragma comment(lib, "./lib/Test00d.lib")
```

与静态库不同的是，动态库还会生成一个`.dll`文件，我们需要把该文件放到和最终的`.exe`文件同一路径下

---

## 对比

- 静态库的`.lib`文件存的是对应方法的实现，而动态库的`.lib`存的是指向对应实现（`.dll`）的索引
- 动态库文件的实现保存在`.dll`文件中，所以只需要用新的`.dll`文件替换原先的即可实现新的功能，不需要编译当前项目生成新的`.exe`文件