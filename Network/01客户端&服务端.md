# 服务端

**注意：别忘记要导入依赖库**

```c++
// 导入依赖库
#pragma comment(lib, "Ws2_32.lib")
```

## 1. 加载库

加载库需要使用`WSAStartup`函数

这里因为需要传入一个`WORD`类型的数来表示版本号，于是要用`MAKEWORD`函数来创造

```c++
WORD word = MAKEWORD(2, // 低位
                     2); // 高位
```

最终会返回一个`int`值来表示是否加载成功

具体代码如下：

```c++
// 1、加载库
WORD word = MAKEWORD(2, // 低位
                     2); // 高位
WSADATA wsaData;
int err = WSAStartup(word, // word用来存储版本号
                     &wsaData);
if (err) {
    cout << "WSAStartup error:" << WSAGetLastError() << endl;
    return 1;
}
else {
    cout << "WSAStartup success" << endl;
}
```

> 其中的`WSAGetLastError`方法用来返回错误的编码

加载成功库后变量`wsaData`中就存储了相关信息，我们可以通过该变量来判断库的版本是否正确

```c++
// 判断一下库是不是2.2版本
if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
    cout << "version error" << endl;

    // 卸载库
    WSACleanup();
    return 1;
}
```

---

## 2. 创建套接字

创建套接字需要使用函数`socket`

我们想要创建基于`UDP`协议和`IPV4`的套接字，于是可以查找相关的帮助文档进行传参

```c++
// 2、创建套接字
SOCKET sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
if (sock == INVALID_SOCKET) {
    cout << "socket error:" << WSAGetLastError() << endl;

    // 卸载库
    WSACleanup();
    return 1;
}
else {
    cout << "socket success" << endl;
}
```

---

## 3. 绑定IP地址

> 这里绑定IP地址的目的是告诉操作系统，发送给（某个网卡+某个端口）的数据是当前进程要接收的数据，交由该程序处理
>
> 因为服务器端一般都是先收信息，所以不绑定的话，操作系统不知道要将哪些信息交由该服务器处理，也就是说程序运行的过程中将永远接收不到信息

绑定IP地址需要使用`bind`方法，查询了相关帮助文档后我们知道，需要传入三个参数：

1. 套接字：大概就是用来判断基于什么协议传输吧

	> 套接字之前已经创建过了，而且只有一个，于是这里无脑丢进去就行了

2. 一个比较复杂的结构体指针：包含了本地的信息，包括端口、网卡（差不多也就是IP地址）等

	> 这个比较复杂，后面细说

3. 传入那个复杂结构体指针的大小：也不知道啥用，直接用`sizeof`计算一下就行了

### 某个复杂的结构体

我们选择一种比较好赋值的这个结构体的替代品来进行赋值，之后要记得强转就行

它的类型是`sockaddr_in`

```c++
sockaddr_in addrServer;
```

先要对该变量赋值之前的`IPV4`家族（姑且先这么称呼）

```c++
addrServer.sin_family = AF_INET;
```

其次，配置端口，这里使用了`htons`方法，可以把数转换为网络字节序（也就是大端存储）

```c++
addrServer.sin_port = htons(12345); // 转换成网络字节序（大端存储）
```

然后，配置网卡

> 一台电脑有很多网卡，我们这里不用写死，所以可以写成任意网卡，让操作系统自动判断，只要有网卡接收到信息通通算作它的

```c++
addrServer.sin_addr.S_un.S_addr = INADDR_ANY; // 绑定任意网卡（关注所有网卡接收到的数据）
```

最后愉快绑定就可以了：

```c++
	// 3、绑定IP地址（告诉操作系统，发给某个网卡+某个端口的数据是当前进程要接收的数据）
	// 192.168.230--十进制四等分字符串类型的ip地址
	// ulong类型的ip地址
	sockaddr_in addrServer;
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(12345); // 转换成网络字节序（大端存储）
	addrServer.sin_addr.S_un.S_addr = INADDR_ANY; // 绑定任意网卡（关注所有网卡接收到的数据）
	//addrServer.sin_addr.S_un.S_addr = inet_addr("192.168.3.233"); // 把字符串类型的IP地址转换成ulong类型的IP地址
	
	err = bind(sock,  (sockaddr*)&addrServer, sizeof(addrServer));
	if (err == SOCKET_ERROR) {
		cout << "bind error:" << WSAGetLastError() << endl;

		// 关闭套接字
		closesocket(sock);

		// 卸载库
		WSACleanup();
		return 1;
	}
	else {
		cout << "bind success" << endl;
	}
```

---

## 4. 接收数据

接收数据要使用`recvfrom`函数

```c++
// 4、接收数据
nRecvNum = recvfrom(sock, // 套接字
                    recvBuf, // 缓冲区用来存储数据
                    sizeof(recvBuf), // 缓冲区大小
                    0, // 判断标记
                    (sockaddr*)&addrClient, // 跟前面一样的复杂的结构体
                    &addrClientSize);
if (nRecvNum > 0) {
    cout << "client ip:" << inet_ntoa(addrClient.sin_addr) << " buf:" << recvBuf << endl;
}
else {
    cout << "recv error:" << WSAGetLastError() << endl;
    break;
}
```

这里客户端那个指针的数据就不用配置了，因为是接收，接收完直接就会把改指针的值给赋值了

也就是接收完后，指针里存的是发送方的信息

> 这里后面又用了`inet_ntoa`是将前面`ulong`类型的ip地址转换成我们平时见到的十进制4等份IP地址，方便我们观察

---

## 5. 发送数据

发送数据使用的方法是`sendto`，参数和接收数据的几乎一样，只不过这里的指针是要有值的，不然不知道你是发给谁的

```c++
// 5、发送数据
gets_s(sendBuf);
nSendNum = sendto(sock, sendBuf, sizeof(sendBuf), 0, (sockaddr*)&addrClient, addrClientSize);
if (SOCKET_ERROR == nSendNum) {
    cout << "sendto error:" << WSAGetLastError() << endl;
    break;
}
```

---

## 6. 关闭套接字&卸载库

```c++
// 关闭套接字
closesocket(sock);

// 卸载库
WSACleanup()
```

---

# 客户端

客户端首先是发信息的，于是可以**不用绑定IP地址**而直接发送，这样发送信息的时候操作系统会自动选择合适的IP分配给它