# 继承（纵向关系）

子类继承父类，可以直接使用父类的成员，也会开辟对应的内存空间（包含父类的信息），也就是说：计算子类大小时是其继承的父类的大小再加上自己本身的大小

格式：子类名称 ： 继承方式 父类名称

```c++
class CSon : public CFather
```

---

当子类成员与父类成员重名时，默认使用子类的，若想使用父类成员则可以利用`父类名称::父类属性`来访问

```c++
void fun()
{
    m_money = 100; // 父类和子类如果有名字冲突，默认使用子类
    CSon::m_money = 101; // 显示的指定使用子类成员，等同于上面的写法
    CFather::m_money = 250;
}
```

```c++
a.fun();
cout << a.m_money << endl;
cout << a.CFather::m_money << endl; 
```

---

子类对象所包含的成员在内存空间的排布顺序：先父类成员（按照成员在类中声明的顺序）再子类成员

```c++
cout << sizeof(CSon) << endl; // 16
cout << &a << endl; // 0113FA28
cout << &a.m_a << endl; // 0113FA28
cout << &a.CFather::m_money << endl; // 0113FA2C
cout << &a.m_b << endl; // 0113FA30
cout << &a.m_money << endl; // 0113FA34
```

---

## 构造函数

顺序：优先调用父类的构造函数，再调用子类的构造函数

在创建子类对象时，先跳转到对应的子类构造函数的初始化参数列表，执行内部的父类构造函数（未指明则默认调用父类的无参构造函数），执行完毕后，顺序继续执行剩下的初始化参数列表，以及后面的构造函数

想要调用有参的构造函数则必须手动显示指明，若既未手动调用，父类又不存在无参构造函数，则会报错

```c++
/* 父类（基类）*/
class CFather
{
public:
	int m_a;
	int m_money;

	CFather(): m_a(11), m_money(100)
	{
		cout << "father" << endl;
	}

	CFather(int a, int b) : m_a(a), m_money(b)
	{
		cout << "fa" << endl;
	}
};

/* 子类（派生类）*/
// 写法： 子类名称： 继承方式 父类
class CSon : public CFather
{
public:
	int m_b;
	int m_money;

	CSon() // 在子类的构造函数初始化参数列表中，编译器会自动调用父类的无参构造
	{
		m_b = m_a;
	}

	CSon(int):CFather() // 也可以手动显示指定出来
	{
		m_b = m_a;
	}

	CSon(int a, int b):CFather(a, b) // 若想要调用父类的有参构造，则必须手动显示指定出来
	{
		cout << "son" << endl;
	}
};
```

---

## 析构函数

顺序：先调用子类的析构，后调用父类的析构

因为是子类对象生命周期的结束所以先调用了子类的析构

在回收子类对象本身的时候，因为包含了父类的成员，在回收父类成员之前，调用父类析构，再回收父类的成员

---

## 继承方式

和访问修饰符共同决定父类的成员在子类表现的属性（父类成员在子类中所使用的范围的权限）

| 父类 / 继承方式 |  public  | protected | private  |
| :-------------: | :------: | :-------: | :------: |
|     public      |   不变   | protected | private  |
|    protected    |   不变   |   不变    | private  |
|     private     | 不可访问 | 不可访问  | 不可访问 |

可得出以下规律：

1. 继承方式为衡量标准，子类中的属性修饰的安全级别**只能比继承方式高**，不足会自动提升到继承方式的安全级别
2. **父类的私有属性**在子类中不论以什么方式继承**都是不可访问的**，也就是说父类的私有属性**只有**父类对象可以用
