# 编译器-运行器

## 程序生成过程

1. 预处理 Preprocessing

	将源文件（`.cpp`）初步处理，生成预处理文件（`.i`）：

	1. 解析 #include 头文件展开替换
	2. 宏定义所有指令：`#define宏`的替换，`#undef`等
	3. 预处理指令：解析`#if`、`#ifndef`、`#else`、`#elif`、`#endif`等
	4. 删除所有注释

2. 编译 Compilation

	将预处理后的文件（`.i`）进行一系列词法分析、语法分析、语义分析及优化，产生相应的汇编代码文件（`.asm`）

3. 汇编 Assembly

	将编译后的汇编代码文件（`asm`）汇编指令逐条翻译成目标机器指令，并生成可重定位目标程序的`.obj`文件，该文件为二进制文件，字节编码时机器指令

4. 链接 Linking

	通过链接器将多个目标文件（`.obj`）和库文件链接在一起生成一个完整的可执行程序

---

## 编译期&运行期

- 编译期：将源代码程序交给编译期编译生成，最终得到可执行程序的过程
- 运行期：将可执行程序交由操作系统执行，退出的过程

### 类和对象

类是编译期的概念，包含了访问权限和成员作用域

而对象的作用域是运行期，它包括类的实例、引用和指针

看如下代码：

```c++
#include <iostream>

using namespace std;

class CFather
{
public:
	virtual void fun()
	{
		cout << "fa::fun" << endl;
	}
};

class CSon : public CFather
{
private:
	void fun()
	{
		cout << "son::fun" << endl;
	}
};

int main()
{
	CFather* pFa = new CSon;
	pFa->fun(); // 可以输出 son::fun
	return 0;
}
```

解释：编译器在检查代码时，会认为`pFa->fun()`调用的是父类中的`public`属性的函数，自然可以通过编译，但在运行期时由于多态的作用，结果调用的是子类的`fun`函数，即使子类的`fun`函数是`private`的，但由于访问修饰符是编译期限制的，所以在运行期无效，子类的`fun`函数自然也能调用

---

## 宏

宏在**预处理阶段**起到替换作用

- 一般写法

	```c++
	 #define N 10
	```

- 宏同样可以传参数，在宏名字后面加`(参数)`即可

	```c++
	#define N(PARAM) int a = PARAM;
	```

	**注意：宏及参数不会像函数传参那样自动计算，也不会做表达式的求解**

	于是就会出现下面的情况：

	```c++
	#define N 2+3
	int a = N*2; //2+3*2 = 8 不是 10
	#define N(A,B) A*B
	int c = N(1+2,3); //1+2*3 = 7 并不是9
	```

	这种情况可以通过使用括号来解决：

	```c++
	#define N (2+3)
	int a = N*2; //(2+3)*2 = 10
	#define N(A,B) (A)*(B)
	int c = N(1+2,3); //(1+2)*3 = 9
	```

- 多行替换

	一般情况下，宏替换当前一行的内容，当要进行多行时可以使用反斜杠`\`，它可以用来连接当前行和下一行

	***注意：最后一行最好不要加`\`，细节没处理好可能会出问题。并且`\`后面不能有任何字符，包括空格、tab、注释等***

	```c++
	#define fly(TIMES) for (int i = 1; i <= TIMES; i++)\
		{\
		cout << i << ' ';\
		}\
		cout << endl;
	```

- 替换为字符串

	使用`#`可以将参数内容替换成字符串

	```c++
	// #:将参数内容转换为字符串，相当于加了双引号
	#define FF(A) #A
	```

- 字符串拼接

	用`##`可以将两边字符进行拼接

	```c++
	// 拼接
	#define GG(H) int a##H = 12;
	
	GG(2);
	cout << a2 << endl; // 输出12
	```

- 转换为字符

	用`#@`可以将后面的字符转化为字符

	```c++
	// #@将参数内容转换为字符，相当于加了单引号
	#define JJ(J) #@J
	
	fun(JJ(12)); // 输出int
	fun(JJ(1)); // 输出char
	```

- 取消某个宏定义

	用`undef`可以取消某个宏定义

	```c++
	#define ll 33
		cout << ll << endl; // 输出33，因为ll被宏定义替换为33
	#undef ll
		int ll = 22;
		cout << ll << endl; // 输出22，宏定义的ll已经被取消了，所以这里是int ll，是一个变量被赋值为22
	```

	