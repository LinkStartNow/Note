# 介绍

> 巧用条件编译可以很大程度上节约资源，优化程序开发，并可以用来实现版本控制
>
> 预处理程序提供了条件编译的功能。条件编译允许只编译源文件中满足条件的程序段，使生成的目标程序较短，从而减少了内存的开销，并提高程序的效率，可以按不同的 条件去编译不同的程序部分，因而产生不同的目标代码文件，提高了程序的可移植性和灵活性
>
> 接下来介绍一些常用的预编译指令

# undef

> 可以取消一个宏的定义

## 举例

```c++
int main()
{
    cout << NUM << endl;    // 未定义
#define NUM 233
    cout << NUM << endl;    // 成功输出
#undef NUM
    cout << NUM << endl;    // 未定义
}
```

> 前面刚开始没有定义NUM，所以第一个编译失败
>
> 第二个刚定义完NUM，所以能成功输出
>
> 第三个由于取消了对NUM的定义，所以编译失败

---

# define

> define定义一个宏一般分为对象宏和函数宏

## 对象宏

对象宏：不带参数的宏被称为"对象宏(objectlike macro)"。对象宏多用于定义常量、通用标识。例如：

```c++
// 常量定义
#define MAX_LENGTH 100
// 通用标识，日志输出宏
#define SLog printf
// 预编译宏
#define _DEBUG
```

---

## 函数宏

函数宏：带参数的宏。利用宏可以提高代码的运行效率: 子程序的调用需要压栈出栈, 这一过程如果过于频繁会耗费掉大量的CPU运算资源。所以，一些代码量小但运行频繁的代码，如果采用带参数宏来实现，会提高代码的运行效率。但是，多数c++程序不推荐使用函数宏，调试上有一定难度，可考虑使用c++的inline代替之。例如：

```c++
 // 最小值函数
#define MIN(a,b) ((a)>(b)? (a):(b))
// 安全释放内存函数
#define SAFE_DELETE(p) {if(NULL!=p){delete p; p = NULL;}}
```

---

# 条件判断

> 这里的条件判断类似于C语言中的条件判断，有if有else if也有else
>
> 最重要的是最后一定要以endif结尾

## ifdef

>  `#ifdef`用于判断某个宏是否定义，和`#ifndef`功能正好相反，二者仅支持判断单个宏是否已经定义。
>
> 只要是定义了这个宏，不论宏的值是多少都算判断成功

## if

> \#if可支持同时判断多个宏的存在，与常量表达式配合使用。

常用格式如下：

```c++
 #if 常量表达式1
// ... some codes
#elif 常量表达式2
// ... other codes
#elif 常量表达式3
// ...
...
#else
// ... statement
#endif
```

> 常量表达式可以是包含宏、算术运算、逻辑运算等等的合法C常量表达式，

**注意：如果常量表达式为一个未定义的宏（在预编译阶段时未定义） 那么它的值被视为0。**

---

### if和ifdef的区别

在判断某个宏是否被定义时，应当避免使用#if，因为该宏的值可能就是被定义为0。而应当使用`#ifdef`或`#ifndef`。看两段段代码，哪段代码会被编译进去，强调下是编译进去，不是执行。

- 代码段1：逻辑1被编译进去程序

	```c++
	#define XXX 0
	// 第一段条件编译
	#ifdef XXX
	  逻辑1
	#else
	  逻辑2
	#endif
	```

- 代码段2：逻辑2被编译进去程序

	```c++
	 #define XXX 0
	// 第二段条件编译
	#if XXX
	  逻辑1
	#else
	  逻辑2
	#endif
	```

> **#if既关心宏是否定义，又关心宏的逻辑的真假。**
>
> **#ifdef**(#if defined())、#ifndef(#if !defined())**仅仅关心宏是否被定义**，不关心宏的逻辑真假。

---

### **#if 0 用于代替 `/\* \*/`注释**

> 当屏蔽掉大块代码时，使用"#if 0"比使用"/**/"要好。（因为用"/**/"做大段的注释时，需要防止被注释掉的代码段中有嵌套的"/**/"，一旦出现"/**/"嵌套"/**/"的情况，会导致你注释掉的代码区域并不是你想要的区域范围） 

```c++
#if 0
    ...code...
#endif
```

