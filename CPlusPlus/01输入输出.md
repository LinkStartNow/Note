# 输入输出

## 基础杂谈

### 面向过程&面向对象

C语言采用一种有序的编程方法——**结构化编程**，C语言是一门面向过程的语言，**更注重程序实现逻辑**、怎么更好、更快、更直接的完成某一功能。同时带来的后果是：不利于程序的**复用性、扩展性**

C++是一门面向对象的语言，更注重**程序的整体设计**，方便程序后期维护、优化和管理。面向对象只有一个价值：**应对需求的变化，本意是要处理大型复杂系统的设计和实现**

####  对比

面向过程的优点：性能比面向对象高，，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素

缺点：没有面向对象易维护、易复用、易扩展

面向对象的优点：易维护、易复用、易扩展，由于面向对象有**封装、继承、多态**的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

缺点：因为类调用时需要实例化，开销比较大，比较消耗资源，性能不如面向过程

> 封装：将零散的数据和算法放到一个集合里，方便管理和使用
>
> 复用性：公共功能、过程的抽象。能被重复使用的类、方法，要求针对某一类功能而不是针对某一个功能去设计
>
> 扩展性：增加新的功能而不影响到原来已经封装好的功能

---

C++中输出用的`cout`对象，输入用的`cin`对象，实际上是定义在文件`iostream`命名空间`std`中的`ostream`和·`istream`类对象，该头文件已经包含了`stdio.h`文件，所以仍然可以用C中的`printf`、`scanf`等

- `C++`很多头文件都没有`.h`,

  ```c++
  #include <iostream> // C++很多头文件没有.h
  ```

​		`iostream`已经包含了`stdio.h`

- `C++`需要打开标准命名空间才能使用一些名词，如`cin`、`cout`

  ```c++
  using namespace std; // 打开标准命名空间
  ```

- 本质上`cin`、`cout`是某一个类型的**变量**；`<<`、`>>`是输入输出符号，本质上是一个**函数**

	***`cin`是`istream`类型的变量，`cout`是`ostream`类型的变量***

- `endl`本质也是**函数**，作用是插入换行符并刷新输出流

- `cout`在输出时若想把`int`类型的变量按`ASCII码`输出则需要用`(char)`强制转换类型

  ```c++
  std::cout << (char)a << std::endl; 
  ```

---

## 作用域运算符`::`

- 正常使用格式为：某一个作用域`::`成员

	如在未打开标准命名空间`std`的情况下使用某些名词，则可以用`std::名词`

	```c++
	std::cout << (char)a << std::endl; 
	```

- 若**未指定作用域**则默认是**全局**

	```c++
	int aa = 20;
	cout << aa << endl; // 局部优先级高于全局，于是会输出20
	cout << ::aa << endl; // 全局的aa
	```

---

## 动态申请空间

`delete`回收空间并不包含指针本身，而是指针指向的内存空间，同一块内存不要重复释放，除非指针已经被赋空，对空指针使用`delete`是安全的。对栈区的内存空间不能用`delete`来释放

关于`new - delete`与`malloc - free`的区别

1. `malloc - free`是C中的**函数**,需要**头文件**的支持，`new - delete`是C++提供的**关键字**，需要C++编译器的支持
2. `malloc`需要传申请空间的大小，**需要手动计算**，返回的是泛型指针(`void*`)，一般**需要强转**为所需要的类型；new后面接的是要申请的类型，会根据类型**自动计算大小**，**不需要强转**
4. 在申请结构体、类空间时，`new`会**自动调用**构造函数，`delete`会**自动调用**析构函数，而`malloc - free`不会
4. `delete`在释放空间时要看指针指向的内容是不是数组，假如是数组则需要用`delete []p`，否则直接`delete p`即可

```c++
#include <iostream>

using namespace std;

int main()
{
	int* p = new int; // 这么书写不会初始化，于是p所指向的内存会存一个奇怪的值
	cout << *p << endl; 
	delete p; // 回收空间
	p = NULL;

	int* p1 = new int(30); // 初始化为30
	cout << *p1 << endl;
	delete p1; // 回收空间
	p1 = NULL;

	int* p2 = new int(); // 初始化默认赋0
	cout << *p2 << endl;
	delete p2; // 回收空间
	p2 = NULL;

	int* p3 = new int[30]; // new 数组，返回的是首元素的地址
	p3[1] = 8;
	cout << p3[1] << endl;
	delete[]p3; // 回收空间
	p3 = NULL;

	int* p4 = new int[10]{}; // 整个数组初始化为0
	cout << p4[3] << endl;
	delete[]p4; // 回收空间
	p4 = NULL;

	int* p5 = new int[10]{1, 2, 3}; // 初始化前三个，剩下来为0
	cout << p5[0] << ' ' << p5[5] << endl;
	delete[]p5; // 回收空间
	p5 = NULL;
}
```

### 各种`new`与`delete`

1. 整形指针

	```c++
	// 整形指针
	int** p = new int*;
	int a = 10;
	*p = &a;
	cout << **p << endl;
	delete p; // 指向的是整形指针，不是数组，所以直接释放p
	p = NULL;
	```

2. 整形指针数组

	```c++
	// 整形指针数组
	int** p = new int* [2]{}; // 初始化数组，内部元素全是空指针
	int a = 20, b = 3;
	p[0] = &a;
	p[1] = &b;
	cout << *p[0] << ' ' << *p[1] << endl;
	delete[]p; // 指向的是一个数组，所以要括号
	p = NULL;
	```

3. 整形数组指针

	```c++
	// 整形数组指针
	int(**p)[2] = new (int(*)[2])(); // 初始化指向的指针为空指针
	int arr[] = { 23, 45 };
	*p = &arr; // p指向的是一个指向数组的指针，所以p相当于三级指针
	cout << (**p)[0] << ' ' << (**p)[1] << endl;
	delete p; // 指向的还是一个指针
	p = NULL;
	```

4. 二维数组

	```c++
	// 二维数组
	int(*p)[2] = new int[][2]{ 2, 3, 4, 555, 6 };
	// 此时的p就相当于2维数组名
	cout << p[1][1] << endl;
	delete[]p;
	p = NULL;
	```

5. 函数指针

	```c++
	// 函数指针
	void (**p)(char) = new (void (*)(char));
	*p = fun;
	(*p)('a');
	delete p;
	p = NULL;
	```

	
