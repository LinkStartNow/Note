# 拓扑排序

## 判断是否有环

[题目链接在这里]([207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/description/?envType=daily-question&envId=2023-09-09))

这里我们通过拓扑排序的方式判断是否有环，过程如下：

1. 首先，将所有的边存储下来（这里以邻接表为例），顺便存储一下每个节点的入度

	```python
	to = [[] for _ in range(numCourses)]
	dushu = [0] * numCourses
	for v, u in prerequisites:
	    to[u].append(v)
	    dushu[v] += 1
	```

2. 遍历一遍所有节点的入度，将入度为0的节点放入队列，表示这些节点已经可以从原图中去除了

	```python
	for i in range(numCourses):
	    if dushu[i] == 0:
	        q.put(i)
	```

3. 反复处理0入度的队列，取出队首，然后将其所有指向的节点的入度-1，若入度为0了则放入该队列，并记录下最终取出的总节点数

	```python
	res = 0
	while q.empty() != True:
	    u = q.get()
	    res += 1
	    for v in to[u]:
	        dushu[v] -= 1
	        if dushu[v] == 0:
	            q.put(v)
	```

4. 最后，如果总共节点数与取出节点数相等，则说明该图没有环，否则说明有

完整代码如下：

```python
from queue import Queue

class Solution:
    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:
        q = Queue()
        to = [[] for _ in range(numCourses)]
        dushu = [0] * numCourses
        for v, u in prerequisites:
            to[u].append(v)
            dushu[v] += 1
        for i in range(numCourses):
            if dushu[i] == 0:
                q.put(i)
        res = 0
        while q.empty() != True:
            u = q.get()
            res += 1
            for v in to[u]:
                dushu[v] -= 1
                if dushu[v] == 0:
                    q.put(v)
        return res == numCourses
```

还有一个[要输出顺序的版本]([力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/course-schedule-ii/submissions/?envType=daily-question&envId=2023-09-10))

稍微改动一下代码即可：

```python
from queue import Queue

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        ans = []
        to = [[] for _ in range(numCourses)]
        rudu = [0] * numCourses
        q = Queue()
        for v, u in prerequisites:
            rudu[v] += 1
            to[u].append(v)
        for i in range(numCourses):
            if rudu[i] == 0:
                q.put(i)
        while q.empty() != True:
            t = q.get()
            ans.append(t)
            for v in to[t]:
                rudu[v] -= 1
                if rudu[v] == 0:
                    q.put(v)
        return ans if len(ans) == numCourses else []
```

## 收集树中的金币（困难）

[题目链接]([2603. 收集树中金币 - 力扣（LeetCode）](https://leetcode.cn/problems/collect-coins-in-a-tree/description/))

> 给你一个 `n` 个节点的无向无根树，节点编号从 `0` 到 `n - 1` 。给你整数 `n` 和一个长度为 `n - 1` 的二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间有一条边。再给你一个长度为 `n` 的数组 `coins` ，其中 `coins[i]` 可能为 `0` 也可能为 `1` ，`1` 表示节点 `i` 处有一个金币。
>
> 一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：
>
> - 收集距离当前节点距离为 `2` 以内的所有金币，或者
> - 移动到树中一个相邻节点。
>
> 你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。
>
> 如果你多次经过一条边，每一次经过都会给答案加一。

思路在题解中给的非常清楚，大致就是，先通过一轮拓扑排序，把外围所有没有金币的节点全部去掉，因为这些节点上面没有金币，也不会有他们之后的节点存在金币，于是这些节点是永远不会到达的（到达他们前面的节点肯定比到达他们更有意义）

然后我们考虑收集范围只有当前节点的情况，这样的话，我们想要收集所有的金币需要把所有外围的叶子节点都走一遍，又由于是树，于是叶子节点的那些父节点都是得经过的，也就是此时需要把所有的节点都走一遍，剩余n个节点总共n-1条边，答案为2 \* (n - 1)，因为要来回

当收集范围为1的时候，我们就只需要绕着次外圈走一圈就够了，我们利用拓扑排序，把当前的叶子节点全部去掉，剩下的叶子节点就全是次外圈的点了，我们需要遍历这些叶子节点，同理，也需要2 * (n - 1)

这里范围变成了2，没啥好说的，直接再走一遍拓扑排序，再剃一轮即可

```python
from queue import Queue
class Solution:
    def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:
        n = len(coins)
        res = n
        e = [[] for i in range(n)]
        rudu = [0] * n


        for u, v in edges:
            e[u].append(v)
            e[v].append(u)
            rudu[u] += 1
            rudu[v] += 1
        q = deque(i for i in range(n) if rudu[i] == 1 and coins[i] == 0)
        while q:
          u = q.popleft()
          rudu[u] -= 1
          res -= 1
          for v in e[u]:
            rudu[v] -= 1
            
            if rudu[v] == 1 and coins[v] == 0:
              q.append(v)
        
        for _ in range(2):
          q = deque(i for i in range(n) if rudu[i] == 1)
          while q:
            u = q.popleft()
            rudu[u] -= 1
            res -= 1
            for v in e[u]:
              rudu[v] -= 1
        return (res - 1) * 2 if res else 0
```

---

# Tarjan算法

## 求lca

> Problem:[P3379 【模板】最近公共祖先（LCA）]([P3379 【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3379))

### 思路

> 用tarjan求lca需要采用离线的方式，我们先将所有的询问以及询问顺序记录下来，然后再用tarjan去求解
>
> 在遍历过程中，我们还需要用到一个vis数组来做标记，我们需要三个状态：
>
> - 0：未访问
>
> - 1：已经访问过，但未回溯
>
> - 2：已经回溯了
>
> 每个点进入访问时，先vis++表示当前节点已经被访问了，防止在后续的dfs中访问又重复访问导致死循环
>
> 我们先将每个邻接的未访问过的节点都访问一遍（因为邻接未访问也就是儿子了），在他们回溯出来后利用并查集将他们的父亲赋值为当前节点，也就并入当前的子树了
>
> 之后，我们去查看与当前节点相关的所有查询，如果那些查询节点v已经有回溯了，并且此次问询尚未被解答，那么这次问询的答案就是v的父亲
>
> 最终这样跑完整棵树也就解答出所有答案了

---

### 细节解释

> 很多人都好奇为啥这样能求出结果，下面谈谈我自己的理解：
>
> 对于两个节点的lca，只会有两种答案情况：
>
> 1. 答案是他们其中的一个节点，也就是说一个节点是另一个节点的父亲
> 2. 答案是他们公共的某个父亲

---

#### 情况1

> 对于情况1，我们在第一次的循环遍历所有子节点的过程中已经完成了他们父节点的确定，得益于并查集的设计，最临近的一层儿子们（假设都为s），他们此时的父亲就是当前节点，他们的儿子们（假设都是ss）的父亲就暂时是他们，此时他们都是已经完成回溯之后的状态了
>
> 于是，我们在后面与当前节点相关的查询中遇到他们时，很明显当前节点就是他们的大祖宗，那么lca就是当前节点，通过GetFa函数查询他们的父亲并进行更新，那么他们的祖孙关系也就建立了，查询出来的最大祖宗就是当前节点，直接写入答案即可

---

#### 情况2

> 第一轮遍历子节点全部完成也就意味着当前的子树已经完全处理完了，当前子树内部的祖宗关系也完事了
>
> 情况2的解答就出现在当前节点的子树的内部遍历中。某个节点在看与自己相关lca查询时，发现了节点v已经完成了回溯，此时该v的最大祖宗就正好也是当前节点的最大祖宗
>
> 我们假设：当前节点为u，目标节点为v，他们的lca为f，由f分出的子树分别为l（包含了v）、r（包含了u）（先假设两棵子树，反正没区别）
>
> 当我们在查询u时发现v已经回溯了，此时v所在的子树l已经并入了f，并且此时正在遍历子树r，刚刚访问到u。
>
> 因为此时f还未完成回溯（毕竟至少f的子树r还未访问完嘛），所以对整颗l查询祖先结果都是f，于是用GetFa查询点v一定也是找到f，所以答案是合理的

---

### Code

```c++
#include <iostream>
#include <vector>
#include <functional>

using namespace std;

int GetFa(vector<int>& fa, int x)
{
    if (x == fa[x]) return x;
    fa[x] = GetFa(fa, fa[x]);
    return fa[x];
}

int main()
{
    int n, m, s;
    scanf("%d%d%d", &n, &m, &s);
    vector<int> fa(n + 1), e[n + 1];
    vector<pair<int, int>> q[n + 1];
    vector<int> ans(m);

    for (int i = 0; i < n + 1; ++i) fa[i] = i;

    for (int i = 0; i < n - 1; ++i) {
        int u, v;
        scanf("%d%d", &u, &v);
        e[u].push_back(v);
        e[v].push_back(u);
    }

    for (int i = 0; i < m; ++i) {
        int u, v;
        scanf("%d%d", &u, &v);
        if (u == v) {
            ans[i] = u;
            continue;
        }
        q[u].push_back({v, i});
        q[v].push_back({u, i});
    }

    vector<int> vis(n + 1);

    function<void(int)> tarjan = [&] (int u) {
        vis[u]++;
        for (int v: e[u]) {
            if (!vis[v]) {
                tarjan(v);

                // 将所有子节点并入当前节点
                fa[v] = u;
            }
        }
        for (auto [x, y]: q[u]) {
            if (vis[x] == 2) {
                ans[y] = GetFa(fa, x);
            }
        }
        vis[u]++;
    };

    tarjan(s);

    for (int x: ans) printf("%d\n", x);
}
```

