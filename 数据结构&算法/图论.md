# 拓扑排序

## 判断是否有环

[题目链接在这里]([207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/description/?envType=daily-question&envId=2023-09-09))

这里我们通过拓扑排序的方式判断是否有环，过程如下：

1. 首先，将所有的边存储下来（这里以邻接表为例），顺便存储一下每个节点的入度

	```python
	to = [[] for _ in range(numCourses)]
	dushu = [0] * numCourses
	for v, u in prerequisites:
	    to[u].append(v)
	    dushu[v] += 1
	```

2. 遍历一遍所有节点的入度，将入度为0的节点放入队列，表示这些节点已经可以从原图中去除了

	```python
	for i in range(numCourses):
	    if dushu[i] == 0:
	        q.put(i)
	```

3. 反复处理0入度的队列，取出队首，然后将其所有指向的节点的入度-1，若入度为0了则放入该队列，并记录下最终取出的总节点数

	```python
	res = 0
	while q.empty() != True:
	    u = q.get()
	    res += 1
	    for v in to[u]:
	        dushu[v] -= 1
	        if dushu[v] == 0:
	            q.put(v)
	```

4. 最后，如果总共节点数与取出节点数相等，则说明该图没有环，否则说明有

完整代码如下：

```python
from queue import Queue

class Solution:
    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:
        q = Queue()
        to = [[] for _ in range(numCourses)]
        dushu = [0] * numCourses
        for v, u in prerequisites:
            to[u].append(v)
            dushu[v] += 1
        for i in range(numCourses):
            if dushu[i] == 0:
                q.put(i)
        res = 0
        while q.empty() != True:
            u = q.get()
            res += 1
            for v in to[u]:
                dushu[v] -= 1
                if dushu[v] == 0:
                    q.put(v)
        return res == numCourses
```

还有一个[要输出顺序的版本]([力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/course-schedule-ii/submissions/?envType=daily-question&envId=2023-09-10))

稍微改动一下代码即可：

```python
from queue import Queue

class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        ans = []
        to = [[] for _ in range(numCourses)]
        rudu = [0] * numCourses
        q = Queue()
        for v, u in prerequisites:
            rudu[v] += 1
            to[u].append(v)
        for i in range(numCourses):
            if rudu[i] == 0:
                q.put(i)
        while q.empty() != True:
            t = q.get()
            ans.append(t)
            for v in to[t]:
                rudu[v] -= 1
                if rudu[v] == 0:
                    q.put(v)
        return ans if len(ans) == numCourses else []
```

## 收集树中的金币（困难）

[题目链接]([2603. 收集树中金币 - 力扣（LeetCode）](https://leetcode.cn/problems/collect-coins-in-a-tree/description/))

> 给你一个 `n` 个节点的无向无根树，节点编号从 `0` 到 `n - 1` 。给你整数 `n` 和一个长度为 `n - 1` 的二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间有一条边。再给你一个长度为 `n` 的数组 `coins` ，其中 `coins[i]` 可能为 `0` 也可能为 `1` ，`1` 表示节点 `i` 处有一个金币。
>
> 一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：
>
> - 收集距离当前节点距离为 `2` 以内的所有金币，或者
> - 移动到树中一个相邻节点。
>
> 你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。
>
> 如果你多次经过一条边，每一次经过都会给答案加一。

思路在题解中给的非常清楚，大致就是，先通过一轮拓扑排序，把外围所有没有金币的节点全部去掉，因为这些节点上面没有金币，也不会有他们之后的节点存在金币，于是这些节点是永远不会到达的（到达他们前面的节点肯定比到达他们更有意义）

然后我们考虑收集范围只有当前节点的情况，这样的话，我们想要收集所有的金币需要把所有外围的叶子节点都走一遍，又由于是树，于是叶子节点的那些父节点都是得经过的，也就是此时需要把所有的节点都走一遍，剩余n个节点总共n-1条边，答案为2 \* (n - 1)，因为要来回

当收集范围为1的时候，我们就只需要绕着次外圈走一圈就够了，我们利用拓扑排序，把当前的叶子节点全部去掉，剩下的叶子节点就全是次外圈的点了，我们需要遍历这些叶子节点，同理，也需要2 * (n - 1)

这里范围变成了2，没啥好说的，直接再走一遍拓扑排序，再剃一轮即可

```python
from queue import Queue
class Solution:
    def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:
        n = len(coins)
        res = n
        e = [[] for i in range(n)]
        rudu = [0] * n


        for u, v in edges:
            e[u].append(v)
            e[v].append(u)
            rudu[u] += 1
            rudu[v] += 1
        q = deque(i for i in range(n) if rudu[i] == 1 and coins[i] == 0)
        while q:
          u = q.popleft()
          rudu[u] -= 1
          res -= 1
          for v in e[u]:
            rudu[v] -= 1
            
            if rudu[v] == 1 and coins[v] == 0:
              q.append(v)
        
        for _ in range(2):
          q = deque(i for i in range(n) if rudu[i] == 1)
          while q:
            u = q.popleft()
            rudu[u] -= 1
            res -= 1
            for v in e[u]:
              rudu[v] -= 1
        return (res - 1) * 2 if res else 0
```

