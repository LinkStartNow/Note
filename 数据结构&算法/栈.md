# 说明

> 栈是一种拥有后进先出的结构，我们可以巧妙地运用栈来实现一些特定的功能

# 一般的栈

## 例题——用栈实现队列

> Problem: [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

### 思路1——无脑互相倒

> 栈的特点是后进先出，而队列是先进后出，因为栈的特点，它的输入顺序和输出是相反的，我们将栈倒往另一个栈，那么此时另一个栈的出栈顺序就是入栈顺序，也就符合队列的特点了
>
> 为了维护入栈顺序，我们在入栈的时候要把输出栈的数据倒回来

#### Code

```c++
class MyQueue {
    stack<int> in, out;
public:
    MyQueue() {

    }
    
    void push(int x) {
        while (out.size()) in.push(out.top()), out.pop();
        in.push(x);
    }
    
    int pop() {
        while (in.size()) out.push(in.top()), in.pop();
        int t = out.top(); out.pop();
        return t;
    }
    
    int peek() {
        while (in.size()) out.push(in.top()), in.pop();
        return out.top();
    }
    
    bool empty() {
        return in.empty() && out.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

---

### 优化

> 我们利用两个栈实际上就是为了获得出栈的顺序和入栈的顺序相同，回想前面的模拟过程，我们所有的输入都是为了输出而服务的，于是在输入的时候我们只需要保证最新加入的数据能在倒往输出栈时能被放到最后输出（也就是最先进），此时其实输出栈的顺序是没有任何问题的，一直用输出栈输出也不会输出出错（但是任何此时往输出栈中的push点都会打破这一个平衡）。输入栈的顺序也符合前面的要求。于是我们可以稍微调整一下翻倒顺序，在输出栈空了以后（不会影响之前正确的输出顺序），再将所有的输入栈元素倒入（符合输出顺序）

#### Code

```c++
class MyQueue {
    stack<int> in, out;
public:
    MyQueue() {

    }
    
    void push(int x) {
        in.push(x);
    }
    
    int pop() {
        int t = peek();
        out.pop();
        return t;
    }
    
    int peek() {
        if (out.empty()) {
            while (in.size()) out.push(in.top()), in.pop();
        }
        return out.top();
    }
    
    bool empty() {
        return in.empty() && out.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

---

# 单调栈

## 例题——股票价格跨度

> Problem: [901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/description/)

### 思路

> 因为需要连续，而且从当前天开始，于是不能有间断，所以只需要从后往前找到第一个比刚加入的价格高的天就行了，再往前的天没有任何意义
>
> 于是我们维护一个单调栈就可以很容易的解决这个寻找的问题，不断从后往前找，遇到小的直接去掉，最终把当前的天加入进去

### Code

```python
class StockSpanner:

    def __init__(self):
        self.Stock = [(-1, inf)]
        self.day = -1


    def next(self, price: int) -> int:
        self.day += 1
        while price >= self.Stock[-1][1]:
            self.Stock.pop()
        self.Stock.append((self.day, price))
        return self.day - self.Stock[-2][0]



# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
```

### 细节

> 刚开始先放入一个最大值，下标假定为-1，这是为了保证单调栈不为空

---

## 例题——下一个更大元素

> Problem: [2454. 下一个更大元素 IV](https://leetcode.cn/problems/next-greater-element-iv/description/)

---

### 思路

> 我们先维护一个优先队列和一个单调栈，假设每个数字都有两条命
>
> 开始时优先队列q和单调栈s都为空，然后一个个去从前往后遍历数组，每遍历一个元素，先看看能不能直接击杀一个前面的数字（仅剩一条命在s中的元素），只要大于全部杀死，直到杀不动为止
>
> 随后再去砍有两条命的，也是同理从栈顶开始砍砍到砍不动为止，每个被砍的数字都会从栈中被弹出放到优先队列中
>
> 最后当前元素放入栈顶

---

### 解释

> 因为每次都是砍到砍不动为止，所以这个栈始终是一个单调递增的栈，栈顶的元素永远最小，一个个依次增大，这也就是个单调栈
>
> 优先队列也是为了保持这个单调递增才设计的

---

### Code

```c++
class Solution {
public:
    vector<int> secondGreaterElement(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n), st;
        priority_queue<int> q;
        for (int i = 0; i < n; ++i) {
            while (!q.empty()) {
                int t = q.top();
                if (nums[i] > nums[t]) {
                    ans[t] = nums[i];
                    q.pop();
                }
                else break;
            }
            while (!st.empty()) {
                int t = st.back();
                if (nums[i] > nums[t]) {
                    st.pop_back();
                    q.push(t);
                }
                else break;
            }
            st.push_back(i);
        }
        while (!q.empty()) {
            int t = q.top();
            ans[t] = -1;
            q.pop();
        }
        while (!st.empty()) {
            int t = st.back();
            ans[t] = -1;
            st.pop_back();
        }
        return ans;
    }
};
```

---

### 优化

> 我们每次用元素去杀死前面的数字，然后都是直到杀不动为止，也就是说第二个队列队首的元素大于等于当前元素，而且在栈中被赶出来的元素都小于当前元素，于是将他们直接加入另一个组也是符合单调的
>
> 而且我们知道，这个优先队列也就是在维护一个功能相同的单调栈，于是我们就可以直接拿栈来代替它
>
> 不过要注意的是，此时从2命栈中出来的元素不能直接放入1命栈中，因为二命栈出来的顺序是从小到大，这样会乱序，我们将他们出来的顺序倒置即可，这里我就又用了一个栈来实现倒置

---

#### Code

```c++
class Solution {
public:
    vector<int> secondGreaterElement(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n), st, st2, ssr;
        for (int i = 0; i < n; ++i) {
            while (!st2.empty()) {
                int t = st2.back();
                if (nums[i] > nums[t]) {
                    ans[t] = nums[i];
                    st2.pop_back();
                }
                else break;
            }
            while (!st.empty()) {
                int t = st.back();
                if (nums[i] > nums[t]) {
                    st.pop_back();
                    ssr.push_back(t);
                }
                else break;
            }
            while (!ssr.empty()) {
                st2.push_back(ssr.back());
                ssr.pop_back();
            }
            st.push_back(i);
        }
        while (!st2.empty()) {
            int t = st2.back();
            ans[t] = -1;
            st2.pop_back();
        }
        while (!st.empty()) {
            int t = st.back();
            ans[t] = -1;
            st.pop_back();
        }
        return ans;
    }
};
```

---

## 例题——美丽塔2

> Problem: [2866. 美丽塔 II](https://leetcode.cn/problems/beautiful-towers-ii/description/)

### 思路

> 这题我们可以尝试将每个元素都作为山峰来挨个尝试遍历，但是这样暴力带来的后果就是n方的复杂度，时间肯定是过不去的。究其原因就是中间有太多的重复计算，我们尝试将他们优化掉
>
> 我们可以通过前后缀拆分的方式来分别考虑这个数组，假设我们先考虑前缀，如果以第i个为山峰，那么它之前的所有元素都得小于等于它，我们可以通过一个单调栈来维护这个结构，每个元素进入时都与栈顶比较，栈顶如果比当前元素大，那么就弹出，继续比较下一个，直到小于等于，将当前元素放入，这样就可以保持这个栈是单调递增的，符合我们山脉的要求
>
> 为了获取到我们弹出元素使影响的数组个数，我们就将下标压入栈即可

---

### Code

```c++
class Solution {
public:
    long long maximumSumOfHeights(vector<int>& maxHeights) {
        long long n = maxHeights.size();
        stack<int> s;
        s.push(-1);
        long long sum = 0;
        long long h[n], t[n];
        for (int i = 0; i < n; ++i) {
            long long x = maxHeights[i];
            while (s.size() > 1 && x < maxHeights[s.top()]) {
                int a, b;
                a = s.top();
                s.pop();
                b = s.top();
                sum -= (long long)(a - b) * maxHeights[a];
            }
            sum += (i - s.top()) * x;
            s.push(i);
            h[i] = sum;
        }
        while (s.size()) s.pop();
        s.push(n);
        sum = 0;
        
        for (int i = n - 1; i >= 0; --i) {
            long long x = maxHeights[i];
            while (s.size() > 1 && x < maxHeights[s.top()]) {
                int a, b;
                a = s.top();
                s.pop();
                b = s.top();
                sum -= (long long)(b - a) * maxHeights[a];
            }
            sum += (s.top() - i) * x;
            s.push(i);
            t[i] = sum;
        }
        
        long long ans = 0;
        for (int i = 0; i < n; ++i) ans = max(ans, h[i] + t[i] - maxHeights[i]);
        return ans;
    }
};
```

---

### 细节处理

> 在压入正向栈的时候，我们先压入一个-1下标，然后判断栈空就用大小大于1来判断，大小为1就为空了
>
> 反向遍历的栈就先压入一个n

