# 例题——股票价格跨度

> Problem: [901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/description/)

## 思路

> 因为需要连续，而且从当前天开始，于是不能有间断，所以只需要从后往前找到第一个比刚加入的价格高的天就行了，再往前的天没有任何意义
>
> 于是我们维护一个单调栈就可以很容易的解决这个寻找的问题，不断从后往前找，遇到小的直接去掉，最终把当前的天加入进去

## Code

```python
class StockSpanner:

    def __init__(self):
        self.Stock = [(-1, inf)]
        self.day = -1


    def next(self, price: int) -> int:
        self.day += 1
        while price >= self.Stock[-1][1]:
            self.Stock.pop()
        self.Stock.append((self.day, price))
        return self.day - self.Stock[-2][0]



# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
```

## 细节

> 刚开始先放入一个最大值，下标假定为-1，这是为了保证单调栈不为空

---

# 例题——下一个更大元素

> Problem: [2454. 下一个更大元素 IV](https://leetcode.cn/problems/next-greater-element-iv/description/)

---

## 思路

> 我们先维护一个优先队列和一个单调栈，假设每个数字都有两条命
>
> 开始时优先队列q和单调栈s都为空，然后一个个去从前往后遍历数组，每遍历一个元素，先看看能不能直接击杀一个前面的数字（仅剩一条命在s中的元素），只要大于全部杀死，直到杀不动为止
>
> 随后再去砍有两条命的，也是同理从栈顶开始砍砍到砍不动为止，每个被砍的数字都会从栈中被弹出放到优先队列中
>
> 最后当前元素放入栈顶

---

## 解释

> 因为每次都是砍到砍不动为止，所以这个栈始终是一个单调递增的栈，栈顶的元素永远最小，一个个依次增大，这也就是个单调栈
>
> 优先队列也是为了保持这个单调递增才设计的

---

## Code

```c++
class Solution {
public:
    vector<int> secondGreaterElement(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n), st;
        priority_queue<int> q;
        for (int i = 0; i < n; ++i) {
            while (!q.empty()) {
                int t = q.top();
                if (nums[i] > nums[t]) {
                    ans[t] = nums[i];
                    q.pop();
                }
                else break;
            }
            while (!st.empty()) {
                int t = st.back();
                if (nums[i] > nums[t]) {
                    st.pop_back();
                    q.push(t);
                }
                else break;
            }
            st.push_back(i);
        }
        while (!q.empty()) {
            int t = q.top();
            ans[t] = -1;
            q.pop();
        }
        while (!st.empty()) {
            int t = st.back();
            ans[t] = -1;
            st.pop_back();
        }
        return ans;
    }
};
```

---

## 优化

> 我们每次用元素去杀死前面的数字，然后都是直到杀不动为止，也就是说第二个队列队首的元素大于等于当前元素，而且在栈中被赶出来的元素都小于当前元素，于是将他们直接加入另一个组也是符合单调的
>
> 而且我们知道，这个优先队列也就是在维护一个功能相同的单调栈，于是我们就可以直接拿栈来代替它
>
> 不过要注意的是，此时从2命栈中出来的元素不能直接放入1命栈中，因为二命栈出来的顺序是从小到大，这样会乱序，我们将他们出来的顺序倒置即可，这里我就又用了一个栈来实现倒置

---

### Code

```c++
class Solution {
public:
    vector<int> secondGreaterElement(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n), st, st2, ssr;
        for (int i = 0; i < n; ++i) {
            while (!st2.empty()) {
                int t = st2.back();
                if (nums[i] > nums[t]) {
                    ans[t] = nums[i];
                    st2.pop_back();
                }
                else break;
            }
            while (!st.empty()) {
                int t = st.back();
                if (nums[i] > nums[t]) {
                    st.pop_back();
                    ssr.push_back(t);
                }
                else break;
            }
            while (!ssr.empty()) {
                st2.push_back(ssr.back());
                ssr.pop_back();
            }
            st.push_back(i);
        }
        while (!st2.empty()) {
            int t = st2.back();
            ans[t] = -1;
            st2.pop_back();
        }
        while (!st.empty()) {
            int t = st.back();
            ans[t] = -1;
            st.pop_back();
        }
        return ans;
    }
};
```

