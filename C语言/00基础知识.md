# 基本数据类型

整形数据类型一般有以下这些：

|      |          关键字          | 字节数（Byte） | 字面值后缀 | 打印格式 |
| :--: | :----------------------: | :------------: | :--------: | :------: |
|  1   |      (signed) char       |       1        |     -      |    %c    |
|  2   |      unsigned char       |       1        |     -      |   %hhu   |
|  3   |   (signed) short (int)   |       2        |     -      |   %hd    |
|  4   |   unsigned short (int)   |       2        |     -      |   %hu    |
|  5   |       (signed) int       |       4        |     -      |  %d或%i  |
|  6   |       unsigned int       |       4        |    u或U    |    %u    |
|  7   |   (signed) long (int)    |       4        |    l或L    |    %l    |
|  8   |   unsigned long (int)    |       4        |   ul或UL   |   %lu    |
|  9   | (signed) long long (int) |       8        |   ll或LL   |   %ll    |
|  10  | unsigned long long (int) |       8        |  ull或ULL  |   %llu   |
|  11  |          float           |       4        |    f或F    |  %f或%e  |
|  12  |          double          |       8        |     -      |  %f或%e  |

括号内的是不用写明的，省略表达的意思也是一样的

有无符号不会改变字节数，而只会影响表示的范围

八进制输出用`%o`，十六进制输出用`%x`

```c
signed int a = 98;
printf("十进制：%d 八进制：%o 十六进制:%x\n", a, a, a);
int iValue = 9;
unsigned int uiValue=9u;
long int lValue = 9l;
unsigned long int ulValue=95ul;
long long int llValue = 95ll;
unsigned long long int ullValue = 95ull;
short int sValue=9;//小于int 按int
unsigned short int usValue=9;
unsigned char ucValue=48;
```

## 原码反码补码

计算机存储的所有数据都是通过补码存储的，于是存储-1的时候就会是`1000000……`第一位是符号位

我们可以巧妙的利用这种方式来求出某些整型的范围：

```c
unsigned short int a = -1;
printf("%hu\n", a);   // 65535
printf("short的范围是：-%hu~%hu\n", a / 2 + 1, a / 2);
```

### 正数转负数

这里的负数指补码，转的时候就把所有位（包括符号）都取反，然后再+1

### 运算

像`+`、`-`这样的运算，就直接补码`+`、`-`即可，然后最终取得的值若是溢出了则只取范围内的位的

## 浮点数的输出

浮点数有三种输出格式：

1. %f：普通的浮点数输出
2. %e：按科学计数法输出
3. %g：最短表示法输出（也就是最短能表示出该值的方式，可能是普通的输出，也可能是科学计数法）

```c
float a = 3.14;
double b = 3.00014;
printf("小数:%f\n科学计数法:%e\n最短表示:%g\n", a, a, a);
printf("小数:%f\n科学计数法:%e\n最短表示:%g\n", b, b, b);
```

> 输出：
>
> float:4
> double:8
> long double:8
> 小数:3.140000
> 科学计数法:3.140000e+00
> 最短表示:3.14
> 小数:3.000140
> 科学计数法:3.000140e+00
> 最短表示:3.00014

## 类型转换

### 隐式转换

规律如下：

1. 整型向浮点型转换
2. 字节少向字节多转换
3. 有符号向无符号转换

```c
#include<stdio.h>
int main()
{
	/*
	自动类型转换(隐式转换)
	*/
	// 相同存储形态，字节数小的向大的转换
	printf("%d\n", sizeof(1 + 9LL));             // 8
	// 不同存储形态，定点向浮点转换
	printf("%d\n", sizeof(9LL + 0.3f));			 // 4
	// 相同类型，有符号向无符号转换
	unsigned a = 10;
	printf("%d\n", a / -2);                      // 0
	printf("%d %d", 2 / -1, 2 / -1u);            // -2 0

	/*
	强制类型转换
	*/
	return 0;
}
```

> 解释：
>
> 第一个由于1与9LL相加，是int与long long相加，同为整型，小的往大的转换，于是最终自动转化为long long，最终输出8字节大小
>
> 第二个是9LL与0.3f相加，是long long与float相加，因为整型向浮点转换，于是会变成float，最终输出4字节
>
> 第三个，2 / -1是有符号整形与有符号整形相除，于是直接计算得的还是有符号整型-1；而另一个是2 / -1u，其中-1u表示的是无符号整型的-1，也就是之前求出来的那个巨大的值，有符号整型遇到无符号整型转换成了无符号整形，于是最后是2 / （int的极限大值），求出来0.0000000x，然后取整就为0了

### 显示转换

也就是强制转换

```c
int a = 3.14; // 自动类型转换
int b = (int)3.14 // 强制类型转换
```

# 运算符

## 关于结合性

首先，运算的第一步是看优先级的，优先级高的一定先运算

当两边优先级相同的时候，就要看结合性来判断左边先还是右边先了

比如`-`的结合方向是从左往右

```c
int a = 2 - 3 - 4;
```

那么这样的情况下，右边就是先算`2 - 3 `，然后再`-4`，而不是先算`3 - 4`再用`2`减

## 第一优先级

**全是从左往右结合的**

- []：数组下标
- ()：小括号
- .：对象成员选择
- ->：指针成员选择

## 第二优先级

**全是右往左结合的**

- -：负号
- ~：按位取反
- ++：自增
- --：自减
- *：指针取值
- &：取地址
- !：逻辑非
- (类型)：强制类型转换
- sizeof()：长度运算符

## 中等优先级

**全是左向右**

- 乘、除、取余
- 加、减
- 左移、右移
- 比较运算符（`>`、`>=`等）
- 等于（`==`）、不等于（`!=`）
- 按位与（`&`）
- 按位异或（`^`）
- 按位或（|）
- 逻辑与（&&）
- 逻辑或（||）

## 条件运算符

`? :`：是个三目运算符，结合方向从右到左，优先级比逻辑或要低

## 赋值运算

各种赋值运算：

**注意：结合性全是从右到左的**

这也是为什么可以：

```c
int x, y, z;
x = y = z = 1;
```

> 实际上是z先被赋值的

- +=
- -=
- <<=
- \>\>=
- &=
- ^=
- |=

## 逗号运算符

优先级最低的运算，也是从左往右的

返回最后一个逗号后的值

```c
#include <stdio.h>

int main()
{
	int a, b, c;
	int m;
	//m = a = 3, b = 4, c = 5, a + b + c;
	m = (a = 3, b = 4, c = 5, a + b + c);
	printf("%d\n", m);
}
```

> 结果m = 12
>
> 因为是从左往右的，于是最后运算a + b + c并返回

```c
#include <stdio.h>

int main()
{
	int a, b, c;
	int m;
	m = a = 3, b = 4, c = 5, a + b + c;
	//m = (a = 3, b = 4, c = 5, a + b + c);
	printf("%d\n", m);
}
```

> 结果m = 3
>
> 我们可以这样来看，首先，由逗号分隔了4个表达式，然后结合由左向右
>
> 于是先运算m = a = 3
>
> 由因为=的结合是右向左，于是先a = 3
>
> 然后m = a，也就是3