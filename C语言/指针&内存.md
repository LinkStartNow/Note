# 大端&小端

- 大端模式：高位存在低地址
- 小端模式：高位存在高地址

大小端模式各有优势，小端模式在强制转换类型时不需要调整字节内容，直接截取低字节即可；大端模式符号位为第一个字节，很方便判断正负

一般的计算机本地存储都是小端存储，而网络中的TCP/IP协议规定为大端模式（这也是为什么网络通信需要转换大小端）

下面是用来验证大小端的代码，配合VS的调试功能方便观察

```c
#include <stdio.h>
int main()
{
	 /*
	 大端模式和小端模式
 一、什么是大端，什么是小端
0x123456在内存中的存储方式

- 大端模式

  低地址 -----> 高地址
  0x12 | 0x34 | 0x56 
- 小端模式

  低地址 -----> 高地址
  0x56 | 0x34 | 0x12 
不难看出大端模式比较符合人的直观认识

二、为什么会有大小端之分
1. 一开始是由于不同架构的CPU处理多个字节数据的顺序不一样，比如x86的是小段模式，KEIL C51是大端模式。但是后来互联网流行，TCP/IP协议规定为大端模式，为了跨平台通信，还专门出了网络字节序和主机字节序之间的转换接口（ntohs、htons、ntohl、htonl）

2. 大小端模式各有优势：小端模式强制转换类型时不需要调整字节内容，直接截取低字节即可；大端模式由于符号位为第一个字节，很方便判断正负。

三、怎样判断大小端
	 */
	int a = 250;
	unsigned int* p = &a;
	*(p + 1) = -1;
	printf("%hhu", *p);
	return 0;
}
```

---

# 指针

## 注意点

1. 指针不要位移到不属于本程序的内存空间，也不要利用指针改变不属于本程序内存空间的数据

2. 见指针的声明

3. 指针的初始值如果没有明确指向目标，则用NULL先赋值

	在C语言中NULL代表空地址，即0号地址

## 指针的声明

一般声明多个指针变量类型时，`*`不能省略

```c
double* p, pp;
double* x, ** xx;
printf("sizeof p = %d, sizeof pp = %d\n", sizeof(p), sizeof(pp));           // 4   8
printf("sizeof x = %d, sizeof xx = %d\n", sizeof(x), sizeof(xx));           // 4   4
```

> 解释一下：为了区分是double类型还是double*类型，选择了32位系统，这样指针的大小就都是4字节了，便于区分
>
> 很显然只有pp是double类型的，所以成功证明，要单独加`*`号才能声明指针

**注意：实际工作中尽量每个写一行，不要粘在一块写**

# 数组

实际上数组和指针区别非常的小，一维数组名就是一个一维指针

数组是一个连续存储的空间，其数组名就是其中第一个元素的地址

比如说，如下代码，实际上都是把数组的首地址赋值给指针

```c
int as[]={10,20,30,40,50};
int *p;
/*1  int型指针 指向int型数组 的意义*/
p = &(as[0]);
p = &*(as + 0);
p = as + 0;
p = as;
```

## 偏移

数组名和指针在偏移的时候可不一样

