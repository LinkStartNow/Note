# 堆区栈区区别

1. 申请、回收：堆区要手动申请和回收，栈区自动分配并回收

2. 生命周期：堆区等用户回收，或整个程序结束自动回收

	栈区在作用域结束后，自动回收

3. 申请效率：栈区申请效率高于堆区

	因为堆区的结构类似于链表，在用户申请空间的时候会遍历链表寻找合适的节点取下来分配给用户，而栈区直接用就行

4. 生长方向：堆区生长方向向上，栈区向下

	也就是说，堆区后申请的空间地址会变大，而栈区会变小

	```c
	#include <stdio.h>
	
	int main()
	{
		int* p = malloc(4);
		int* pp = malloc(4);
		printf("%d\n", p);     //  21273440
		printf("%d\n", pp);    //  21273488
	
		int a;
		int b;
		printf("%d\n", &a);   // 19921092
		printf("%d\n", &b);   // 19921080
	}
	```

5. 内存碎片：堆区会产生碎片，栈区不会

6. 存储内容不同：栈区存局部变量、函数入口地址

	堆区比较随意

# 大端&小端

- 大端模式：高位存在低地址
- 小端模式：高位存在高地址

大小端模式各有优势，小端模式在强制转换类型时不需要调整字节内容，直接截取低字节即可；大端模式符号位为第一个字节，很方便判断正负

一般的计算机本地存储都是小端存储，而网络中的TCP/IP协议规定为大端模式（这也是为什么网络通信需要转换大小端）

下面是用来验证大小端的代码，配合VS的调试功能方便观察

```c
#include <stdio.h>
int main()
{
	 /*
	 大端模式和小端模式
 一、什么是大端，什么是小端
0x123456在内存中的存储方式

- 大端模式

  低地址 -----> 高地址
  0x12 | 0x34 | 0x56 
- 小端模式

  低地址 -----> 高地址
  0x56 | 0x34 | 0x12 
不难看出大端模式比较符合人的直观认识

二、为什么会有大小端之分
1. 一开始是由于不同架构的CPU处理多个字节数据的顺序不一样，比如x86的是小段模式，KEIL C51是大端模式。但是后来互联网流行，TCP/IP协议规定为大端模式，为了跨平台通信，还专门出了网络字节序和主机字节序之间的转换接口（ntohs、htons、ntohl、htonl）

2. 大小端模式各有优势：小端模式强制转换类型时不需要调整字节内容，直接截取低字节即可；大端模式由于符号位为第一个字节，很方便判断正负。

三、怎样判断大小端
	 */
	int a = 250;
	unsigned int* p = &a;
	*(p + 1) = -1;
	printf("%hhu", *p);
	return 0;
}
```

---

# 指针

## 注意点

1. 指针不要位移到不属于本程序的内存空间，也不要利用指针改变不属于本程序内存空间的数据

2. 见指针的声明

3. 指针的初始值如果没有明确指向目标，则用NULL先赋值

	在C语言中NULL代表空地址，即0号地址

## 指针的声明

一般声明多个指针变量类型时，`*`不能省略

```c
double* p, pp;
double* x, ** xx;
printf("sizeof p = %d, sizeof pp = %d\n", sizeof(p), sizeof(pp));           // 4   8
printf("sizeof x = %d, sizeof xx = %d\n", sizeof(x), sizeof(xx));           // 4   4
```

> 解释一下：为了区分是double类型还是double*类型，选择了32位系统，这样指针的大小就都是4字节了，便于区分
>
> 很显然只有pp是double类型的，所以成功证明，要单独加`*`号才能声明指针

**注意：实际工作中尽量每个写一行，不要粘在一块写**

# 数组

实际上数组和指针区别非常的小，一维数组名就是一个一维指针

数组是一个连续存储的空间，其数组名就是其中第一个元素的地址

比如说，如下代码，实际上都是把数组的首地址赋值给指针

```c
int as[]={10,20,30,40,50};
int *p;
/*1  int型指针 指向int型数组 的意义*/
p = &(as[0]);
p = &*(as + 0);
p = as + 0;
p = as;
```

## 数组名

数组名就是数组首元素的地址

```c
int a[3];
```

此时`sizeof(a)`就是整个数组的大小

```c
#include <stdio.h>

int main()
{
	int a[3];
	printf("%d\n", sizeof(a)); // 12
}
```

`&a`也是取整个数组的首地址

## 偏移

我们都知道数组名相当于一维指针，也就是说：`arr[] = [1, 2, 3]`和`int* a = arr`

这样的arr和a的意义是一样的，而且他们的偏移情况也是相同的，都是4字节偏移

```c
int as[]={10,20,30,40,50};
int* a = as;
printf("as = %d, as + 1 = %d\n", as, as + 1);
printf("a = %d, a + 1 = %d\n", a, a + 1);
```

> 输出：
>
> as = 20183096, as + 1 = 20183100
> a = 20183096, a + 1 = 20183100

但是数组名也是可以取地址的，此时的偏移就不一样了，取地址后的数组名相当于二维指针，每次偏移一整个数组的字节数：

```c
#include <stdio.h>
int main()
{
	int as[]={10,20,30,40,50};
	int* a = as;
	printf("as = %d, as + 1 = %d\n", as, as + 1);
	printf("a = %d, a + 1 = %d\n", a, a + 1);
	printf("&as = %d, &as + 1 = %d\n", &as, &as + 1);
	/*1 数组名的真正作用：数组整个存储空间的首地址,也代表第0个元素的地址*/

 	/*2 数组名+偏移量操作成员空间*/

 	/*3 深度理解[] 作为运算符的作用：就是指针移动*/
	return 0;
}
```

> 输出：
>
> as = 14023624, as + 1 = 14023628
> a = 14023624, a + 1 = 14023628
> &as = 14023624, &as + 1 = 14023644

## *运算符

*运算符实际上就是对当前指针的降维，若是一维指针就直接解出值了

```c
int a = 3;
int* b = &a;
printf("b = %d, *b = %d\n", b, *b);
```

> 输出：
>
> b = 4193448, *b = 3

## []运算符

是的，你没看错，实际上这个数组常用的中括号是一个运算符

`a[n]`与`*(a + n)`是等价的，总结就是，先偏移后取值

```c
int arr[] = { 2, 3, 5, 777 };
int* p = arr;
printf("%d\n", arr[3]);
printf("%d\n", *(p + 3));
```

> 输出：
>
> 777
>
> 777

## 指针数组

### 定义

本质是个数组，每个成员都是指针

### 声明

类似于`int* p[]`

### 实践

```c
#include <stdio.h>
int main()
{
	int a=1,b=2,c=3,d=4,i;
	// 指针类型的数组简称：指针数组。 每个数组成员都是指针变量。
	int ssr[] = { 5, 6, 7, 8 };
	int *p[]={ &a, &b, ssr};
	printf("%d %d %d %d\n", p[0], p[1], p[2], p[2] + 3);
	printf("%d %d %d %d\n", *p[0], *p[1], *p[2], *(p[2] + 3));
	 
	return 0;
}
```

> 输出：
>
> 2161864 2161852 2161792 2161804
> 1 2 5 8

## 数组指针

### 定义

本质上是个指针，指向一个数组

### 声明

类似于：`int (*p)[4]`

声明了一个指向大小为4的数组的指针

其实也不一定要指向大小为4的数组，只是说默认的偏移会以4个int大小的数组为单位偏移

### 实践

```c
int a[] = { 2, 3, 5 };
int(*p)[5] = &a;
printf("a[2] = %d, (*p)[2] = %d\n", a[2], (*p)[2]);
printf("&a = %d, p = %d\n", &a, p);
printf("&a + 1 = %d, p + 1 = %d\n", &a + 1, p + 1);
return 0;
```

> 输出：
>
> a[2] = 5, (*p)[2] = 5
> &a = 11925948, p = 11925948
> &a + 1 = 11925960, p + 1 = 11925968

## 二维数组

### 瞎逼逼

长度固定，有编号（先行后列），逻辑造型就是表格矩形状

### 内存分配

内存分配上是连续的，例如`int a[2][3]`的二维数组

其实`a[0][2]`和`a[1][0]`是相邻的

实际上，我们应该将该二维数组看成两个数组a[0]和a[1]，每个数组中的元素都是三位数组

```c
int arr[3][4];
arr[0][0] = 1; arr[0][1] = 1; arr[0][2] = 1; arr[0][3] = 0;
arr[1][0] = 1; arr[1][1] = 0; arr[1][2] = 0; arr[1][3] = 0;
arr[2][0] = 0; arr[2][1] = 0; arr[2][2] = 0; arr[2][3] = 0;
printf("&arr[0][3] = %d, &arr[1][0] = %d\n", &arr[0][3], &arr[1][0]);
```

> 输出：
>
> &arr\[0][3] = 9434832, &arr\[1][0] = 9434836

### 初始化

初始化的时候可以直接赋值，也可以不赋值

```c
int aa[2][3] = { {2, 3}, {5} };
int b[2][3];
```

声明的时候可以不赋值行数，但是一定要确定列数

```c
int a[][3] = { 2, 3, 5 };
int aa[2][3] = { {2, 3}, {5} };
```

初始化的时候可以按照一维数组的模样只用一个大括号，也可以在里面分别用大括号分割行

**注意：他们的结果可不一样哦，不分割的情况下会按一个个连续的位置放，但分割了后就放到下一行去，空位用0填充**

```c
int a[][3] = { 2, 3, 5 };
int aa[2][3] = { {2, 3}, {5} };
```

初始化中所有的空位用0填充

### 实践

```c
#include <stdio.h>
int main ()
{
	/* 二维数组 在 声明的同时 直接初始化赋值  */
	

	/* 1  完全初始化：形式1：一维摸样 形式2：{}行方式  */
	int a[][4] = { 2, 3, 5 };
	int aa[2][4] = { {2, 3}, {5} };
	int b[2][4];
	int bb[][4] = { {2, 3}, {5} };
	 
	/* 2 不完全初始化、其它成员默认 0     */

	/* 3 初始化成员个数 列数不能省略,根据列数自动决定行数。  */
	 
	/*4 循环遍历 每个成员 */
	for (int i = 0; i < 2; ++i)
		for (int j = 0; j < 4; ++j)
			printf("a[%d][%d] = %d\t", i, j, a[i][j]);
	printf("\n");
	for (int i = 0; i < 2; ++i)
		for (int j = 0; j < 4; ++j)
			printf("aa[%d][%d] = %d\t", i, j, aa[i][j]);
	printf("\n");
	for (int i = 0; i < 2; ++i)
		for (int j = 0; j < 4; ++j)
			printf("b[%d][%d] = %d\t", i, j, b[i][j]);
	printf("\n");
	for (int i = 0; i < 2; ++i)
		for (int j = 0; j < 4; ++j)
			printf("bb[%d][%d] = %d\t", i, j, bb[i][j]);
	
	 
	return 0;
}
```

> 输出：
>
> a\[0][0] = 2     a\[0][1] = 3     a\[0][2] = 5     a\[0][3] = 0     a\[1][0] = -858993460    a\[1][1] = 641461004     a\[1][2] = 18085908      a\[1][3] = 1714787
> aa\[0][0] = 2    aa\[0][1] = 3    aa\[0][2] = 0    aa\[0][3] = 0    aa\[1][0] = 5    aa\[1][1] = 0    aa\[1][2] = 0    aa\[1][3] = 0
> b\[0][0] = -858993460    b\[0][1] = -858993460    b\[0][2] = -858993460    b\[0][3] = -858993460    b\[1][0] = -858993460   b\[1][1] = -858993460     b\[1][2] = -858993460    b\[1][3] = -858993460
> bb\[0][0] = 2    bb\[0][1] = 3    bb\[0][2] = 0    bb\[0][3] = 0    bb\[1][0] = 5    bb\[1][1] = 0    bb\[1][2] = 0    bb\[1][3] = 0  

### 二维数组名

二维数组名实际上就是个二维指针，可以通过偏移轻松获得某行的首地址

然后取值后降维变成一维指针，又可以轻松获得该行内某列的地址

对二维数组名取地址还能获得对应的二维数组指针，轻松跨度整个数组
