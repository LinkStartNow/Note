# 终端的某些符号

- `~`代表当前用户的文件夹路径，如`home/Myname`

	**注意：在桌面或者home文件夹下打开终端进入的都是`~`**

- `$`表示当前是一个普通用户
- `#`表示此时的用户是root用户
- `/`代表根目录，在根目录下打开终端，此时的路径就是`/`

# Linux文件夹

Linux系统中的一切文件都是从“根 （/）”目录开始的，下面列举一些文件夹：

- `/boot`：开机所需文件—内核、开机菜单以及所需配置文件等
- `/dev`：以文件形式存放任何设备与接口
- `/etc`：配置文件
- `/home`：用户主目录
- `/bin`：存放单用户模式下还可以操作的命令，一般放的是可执行文件
- `/lib`：开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数
- `/sbin`：开机过程中需要的命令
- `/media`：用于挂载设备文件的目录
- `/opt`：放置第三方的软件
- `/lost+found`：当文件系统发生错误时，将一些丢失的文件片段存放在这里
- `/proc`：虚拟文件系统，例如系统内核、进程、外部设备及网络状态等

# shell指令

Shell：命令解释器，根据输入的命令执行相应的动作

终端的本质是一个进程，里面跑的是命令解析器，可以解析输入的命令

# 快捷键

- 清屏：ctrl  + l，或者命令clear
- delete光标前面：Backspace（也就是回退键）
- delete光标后面：ctrl + d
- 光标来到最前面：ctrl + a~~（我就是喜欢用home！！！）~~
- 光标来到最后面：ctrl + e~~（end才是yyds！！！）~~
- 查看前面/后面输入的指令：Ctrl + p/n，或者上下键
- 查看历史输入指令：history

# C语言标准函数与系统的区别

C标准函数，在Linux系统中执行，会先去调用应用层的API，然后调用系统层的API，通过系统层 API去调用驱动中的函数，输出到对应的设备中。

## C语言文件指针

该文件指针是一个大的结构体，包括三个部分：

1. 文件描述符：指向真实文件

2. f_pos：当前这个文件读写到什么位置了

3. buffer缓冲区：大小一般为8192B（8KB）

	在正常写文件时会等到缓冲区满了再写，或者手动调用flush刷新缓冲区进行写入

# PCB

## 虚拟内存

每个进程创建加载的时候，都会被分配一个4G的连续的虚拟地址空间，其中0-3G为用户空间，3G-4G为内核空间。

内核通过PCB管理进程，PCB中有一个files_struct结构体，就是当前这个应用所有的文件，这个结构体是一个指针，指向一个int数组，也就是文件描述符数组。进程会默认打开三个文件描述符，分别是标准输入、标准输出和标准出错**（WSAGetLastError就是通过这个文件查看错误的）**。进程内部也可以打开其他文件，比如用fopen打开了一个文件，就会在数组中找到空闲的最小数字作为这个打开文件的描述符，指向这个文件

# 最大打开文件个数

## 查找最大打开文件个数的命令

`cat /proc/sys/fs/file-max`

## 修改

`ulimit -n 4096`

> 最大个数改为4096，临时有效，重启系统后失效

# 文件系统

Windows现在文件系统都是NTFS的，以前的U盘有FAT32文件系统的，FAT32文件系统的的单个文 件是不能超过4G的。Linux的文件系统有ext2，现在最新的是ext4 文件系统。

## 扇区

扇区，是指磁盘上划分的区域。磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇 区，硬盘的读写以扇区为基本单位。

每个扇区的大小是512个字节，文件在磁盘中存储包括三个信息：

1. 文件名
2. 起始位置：文件实际存储在磁盘中的地址，配合文件大小就可以取出一个文件
3. 文件大小

## ext2文件系统

文件系统中存储的最小单位是块 （Block），一个块究竟多大是在格式化时确定的，**默认是4KB**，也就是8个扇区，多个Block用一个Block Group管理，文件系统由多个Block Group组成

每个块内存储的内容不一样，把存储不同内容的块组合到一起形成一个块组 （Block Group）

启动块：大小确定，1KB。启动块是由PC标准规定的，用来存储磁盘分区 信息和启动信息，任何文件系统都不能使用启动块。启动块用来存储磁盘分了多少个区。

下面以一个Block Group为例进行说明：

每个块里面包含六个部分：超级快、GDT（块组描述符表）、块位图、inode位图、inode表、 data block（数据块）

1. 超级快：主要存储的是快大小、文件系统版本号、上次挂载的时间

2. GDT（group description table块组描述符表）：不确定大小，可能由很多个块组成。描述的是 第几个块开始是block bitmap，第几个块开始是inode bitmap、第几个块开始是inode table、第几个块 开始是data block和空闲块、空闲inode有多少。也就是标记了每一种块的起始位置

3. 块位图（block bitmap）：1个block，用每个bit位标识每个块是否被使用，标识的块如果被使用，对应的 位就会被置为1，如果块没有被使用，对应的位就是0。

4. inode位图（inode bitmap）：1个block，用每个bit位标识每个inode是否被使用。

	> inode就是用来存储文 件类型（常规、目录、符号连接等）、权限、文件大小、创建/修改/访问时间等，ls -l命令可以看到的信 息。简而言之，inode是用来存储文件属性和数据块指针。

5. inode表（inode table）：一系列的inode存储在一起，形成的了一个inode table。每个 inode128字节，1block可以存32个inode，每个文件都需要1个inode。与inode位图配合使用，inode 位图存储的就是inode表中的某个inode节点有没有被使用。每个inode中存的是文件属性和文件块指 针，文件块指针有60个字节，每个指针4个字节，可以存储15个指针。
6. data block（数据块）：可以理解成数据块表，也是一系列数据块存储在一起，形成的表，数据 块表可能由很多个block组成，这里就以4个block为例。与块位图配合使用，块位图里面存储的就是具体 哪个数据块被使用的情况。

## 读写文件的过程

1. 首先看Boot Block看磁盘分区，找到要存储的磁盘。
2. 来到具体的磁盘里的block group，可以直接跳过超级快，没啥用。
3. 到GDT表里面，从GDT表中读取出块位图、inode位图、inode tabl和data block的起始位置。
4. 通过inode位图找到空闲的inode 节点，写入文件属性。
5. 通过块位图找出空闲的data block，向空闲的data block中写入文件内容“hello”，并把data block的 地址赋值给写入文件属性的那个inode 节点。

## 数据块寻址

一个inode节点中有数据块指针60字节，可以存15个地址指针，一个地址是4K，一个文件大小就是 15*4K=60K。假如文件比较大，那么肯定就存不下了

实际上这15个指针并不全指向数据块，前12个指向数据块，后三个比较特殊：

- block[12]：一级间接寻址指针
- block[13]：二级间接寻址指针
- block[14]：三级间接寻址指针

这里以block[12]为例分析一下：

block[12]指向了一个块，一个块有4k那么大，而一个指针的大小是4字节，于是可以存储的指针个数为4096 / 4 = 1k，而每个指针又指向了一个4k的block，于是可以存储的大小为1k * 4k = 4M

block[13]为二级指针，指向了1k个一级指针，所以可以存储大小为1k * 4M = 4G

同理block[14]可以存储4T

## 文件名和目录存储

每个文件夹都有一个对应的文件去存储这个文件夹的信息和文件里面所有文件的相关信息，叫做记 录项。所以创建一个空的文件夹，文件夹的大小都是4K，也就是1个block。

记录项包含：文件名、inode号、文件类型和记录长度。根据这个inode号就可以在inode table里面 查找到对应的文件属性和数据快指针。进而进行下一步的读写删除操作。

## 虚拟文件系统

打开文件的时候，文件描述符的数组会分配一个最小号的描述符，文件描述符会指向一个file结构 体。这个file结构体里面包含读写指针位置、flags（标志，不用关心）、f_op、f_dentry和引用计数。其 中比较重要的是f_op和f_dentry。

f_op指向的是驱动层的file_operation结构体，它是知道当前文件系统实际是一个什么类型的文件系 统的，驱动层是专门操作硬件的。

f_dentry是指向磁盘文件的。磁盘文件类似于inode，里面有文件属性和数据块，会指向文件系统的 驱动inode_operations，里面有操作文件属性的函数chmod、link、unlink等，可以对文件属性进行操 作。

因为读写指针位置的存在，所以即使多个文件描述符指向同一个file结构体，写入数据也不会覆盖（先不考虑多线程）

**注意：如果是多个进程打开了相同的文件，那么他们创建的file结构体是不同的，最后写的数据会覆盖前面的数据**