# Orphan Process 孤儿进程

父进程先于子进程退出，子进程失去托管，这种子进程统称为孤儿进程

## 危害

- 导致内存泄漏，影响新进程的创建
- 孤儿进程的危害不可预测，如果一个孤儿进程持续的申请系统资源，这导致影响系统稳定性

## 检测处理模型

### 1.子进程检测父进程异常，辨别孤儿进程后退出

其中可以利用`ppid = getppid();`获得父进程pid

用`kill(pid, 0)`，然后再通过判断`errno == ESRCH`来判断父进程是否还存在

**注意：kill函数的机制是得先kill然后再观察errno才行，而不是直接拿返回值判断**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <signal.h>
#include <errno.h>

int main() {
	pid_t pid;
	int i = 0;
	for (; i < 2; ++i) {
		pid = fork();
		if (pid == 0) break;
	}

	if (pid > 0) {
		printf("parent pid %d is alive\n", getpid());
		sleep(5);
		printf("parent is dead\n");
	}
	else if (pid == 0) {
		pid_t ppid = getppid();
		while (1) {
			printf("child i %d pid %d is working parent id %d\n", i, getpid(), ppid);
			kill(ppid, 0);
			if (errno == ESRCH) {
				printf("child i %d is dead\n", i);
				exit(0);
			}
			sleep(1);
		}
	}
	else {
		perror("fork fail");
	}
	return 0;
}
```

### 2.创建检测进程，若父进程退出则以组为单位杀死全部孤儿进程

主程序：

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/types.h>

int main() {
	pid_t pid;
	int i = 0;
	for (; i < 5; ++i) {
		pid = fork();
		if (pid == 0) break;
	}

	if (pid == 0) {
		printf("child %d is running\n", getpid());
		while (1) {
			sleep(3);
			printf("child i %d is alive\n", i);
		}
	}
	else if (pid > 0) {
		int wfd;
		char str_pid[10];
		bzero(str_pid, 10);
		if ((wfd = open("fifo", O_RDWR)) == -1) {
			perror("open fail");
			exit(0);
		}
		sprintf(str_pid, "%d", getpid());
		write(wfd, str_pid, strlen(str_pid));
		sleep(10);
		write(wfd, "exit", 5);
		exit(0);
		wait(NULL);
	}
	else {
		perror("fork fail");
	}

	return 0;
}
```

检测进程：

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <errno.h>

int main() {
	int rfd;
	if ((rfd = open("fifo", O_RDWR)) == -1) {
		perror("open fail");
		exit(0);
	}
	char buf[10];
	bzero(buf, 10);
	read(rfd, buf, 10);
	pid_t pid = atoi(buf);
	printf("check process pid %d get parent pid %d\n", getpid(), pid);

	// 非阻塞读取管道
	// 1.获取文件属性
	int flag;
	fcntl(rfd, F_GETFL, &flag);
	flag |= O_NONBLOCK;
	fcntl(rfd, F_SETFL, flag);

	int len;
	int esrch;
	char str_pid[10];
	bzero(str_pid, 10);

	while ((len = read(rfd, buf, sizeof(buf))) == -1) {
		if (errno == EAGAIN) {
			// 非阻塞返回，进行一次试探
			kill(pid, 0);
			if (errno == ESRCH) {
				printf("check parent %d is dead\n", pid);
				sprintf(str_pid, "-%d", pid);
				// 杀死孤儿进程
				printf("执行命令 kill -9 %s\n", str_pid);
				kill(-pid, 9);
				//execl("/bin/kill", "kill", "-9", str_pid, NULL);
				exit(0);
			}
			printf("check parent alive..\n");
		}
		else {
			perror("read fail");
			exit(0);
		}
		sleep(1);
	}
	if (len > 0) {
		printf("has received parents has dead pid %d\n", pid);
		sprintf(str_pid, "-%d", pid);
		// 杀死孤儿进程
		printf("执行命令 kill -9 %s\n", str_pid);
		kill(-pid, 9);
		//execl("/bin/kill", "kill", "-9", str_pid, NULL);
		printf("parent exit, check_process Done..\n");
		exit(0);
	}
	return 0;
}
```

> 主进程在睡眠10秒后会自动死亡，然后通过管道发送自己死亡的消息，通知检测进程杀死子进程
>
> 如果在睡眠的过程中主动杀死了主进程，那么检测进程就能检测出来，也会杀死这个组

# 亲缘关系

- 强亲缘：比如父进程和子进程，父进程创建子进程后，直到子进程结束，父进程全程干预
- 弱亲缘：像爷孙之间的关系，只有继承，没有其他管理关系

## 终端进程

实际上我们打开的终端就是一个bash进程，也是一个进程。然后我们的`./app`，实际上就是bash调用了fork创建了一个新进程然后再execl了该程序，然后开始执行。这个由bash创建的进程就是**终端进程**，它是bash的子进程

调用命令大概也是如此，也是创建了进程后又execl了命令

当然一般bash也就这么一个”亲儿子“，这也就是为什么我们的程序阻塞的时候不能用其他命令了、

# Process Group进程组关系

为了方便管理系统中的大量进程，设计了进程组结构

进程组由一个组长进程和多个组员进程构成

**每个终端进程都是组长进程**，组长的标志就是pid和ppid相等

进程组的生命周期较长，与某个特定的进程无关，直到组中最后一个进程终止或转移，进程组为空，系统会释放进程组

根据就近原则，组长进程创建的子进程会归纳到父进程同组变为组员进程

**进程组关系与亲缘关系没有必然联系，因为组成员可以转移**

## 创建

**创建进程组只有组员进程可以完成，组长无法成功**

我们可以用`getpgrp()`获得当前进程的组id，来判断是否是组长进程

然后可以通过`setpid(pid_t pid, pid_t gpid)`来创建组或转移组中的进程

一般创建组就直接用`setpid(getpid(), getpid());`

转移的话就用`setpid(getpid(), 1000);`

转移进程要保证对目标有足够的访问权限，其次目标组要存在

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
	int i = 0;
	pid_t pid;
	for (; i < 2; ++i) {
		pid = fork();
		if (pid == 0) break;
	}

	if (pid == 0) {
		printf("child i %d pid %d, gpid %d\n", i, getpid(), getpgrp());
		if (i == 1) {
			setpgid(getpid(), getpid());
		}
		printf("child i %d pid %d, gpid %d\n", i, getpid(), getpgrp());

		while (1) sleep(1);
	}
	else if (pid > 0) {
		printf("parent pid %d, gpid %d\n", getpid(), getpgrp());
		while (1) sleep(1);
	}
	return 0;
}
```

# Process Session会话关系

会话关系便于终端或系统管理终端进程和终端子进程

会话由一个会话发起者和多个会话参与者构成

会话发起者退出，以进程组为单位杀死参与者

**只杀死终端进程为首的一组进程**

会话发起者的标志是pid = gid = sid

**本质上就是杀死终端进程那一组的进程**

## 脱离终端

后续开发app的时候，要进行脱离控制终端，避免会话发起者bash接收，杀死进程

脱离终端有两种方式：

1. 组独立：终端进程创建的子进程自己再自立为王成立一个组，这样gid就和终端进程不同了，也就不会被杀死了
2. 会话独立：终端进程创建的子进程自己发起一个会话，这样就和bash不在一个会话中了，也就不会被杀死了

**注意：无论哪种脱离方式，终端进程始终无法脱离终端，必然受终端控制，因为它无法创建组也无法成立新会话**

## 会话独立

可以通过`getsid(getpid());`获得当前进程的会话id，这里因为需要传入pid于是直接调用getpid

然后再调用`setsid();`方法创建新会话

**注意：新会话只能由组员进程才能发起**，理由如下：

> 我们都知道，会话发起者的三个id都相等，于是创建新会话首先要变成组长，于是该函数会先创建一个新组，这一步组长便完成不了，于是只有组员能实现

在实际开发过程中，有些进程人们会让他们脱离终端的控制，手动关闭其父进程，让他们工作于后台，周期执行，这类进程称为**守护进程**，**还是孤儿**

