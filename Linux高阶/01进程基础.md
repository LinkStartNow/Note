# 基础理论

进程作为操作系统的基本调度单位，占用系统资源（如CPU、内存）完成特定的任务，所以说进程是操作系统的标准执行单元

## 进程与程序的区别

程序是静态资源，存储于电脑磁盘中（disk磁盘资源）

程序执行后会创建进程，负责完成功能，进程是程序启动后的结果，是程序的动态表现（CPU、内存、磁盘）

## 共享访问

将硬件资源CPU、内存、缓存、硬盘等进行共享，多进程可以同时访问使用这些资源，实现硬件利用最大化，最终诞生了多任务操作系统，即在一台设备商可以同时执行多个任务（Process进程），最好的利用硬件资源

### CPU共享

采用分时复用原则（可以将CPU的执行时间切割为若干时间片，时间片分发给乧进程，让多个进程可以交替轮转使用CPU）

### 内存共享

内存资源是可以被多个进程访问和共享的，不会给进程分配固定占用的内存，这样会影响内存的重用性

## 进程的生存环境

一般情况下，操作系统会给一个进程分配4g的内存空间，其中0-3g为用户层，3-4g为内核层（系统层）

这4g其实是指虚拟内存，可以当做真实的内存来使用，使用的时候实际上是对应映射到物理内存中。**占用的物理内存远比虚拟内存中的地址小的多**

内存管理系统中有**虚拟内存映射表**，记录映射关系

### 内核层

用来存储进程信息

主要用来存储进程控制块（PCB），其中包含了所有进程相关的信息（例如PID），**只有操作系统有访问权限**

内核层内存是共享内存，多个进程可以共享同一块内存，**因为内核层只有操作系统才有访问权限，所以不怕被用户误修改**

### 用户层

用来存储进程的功能与逻辑

**注意：每个进程都拥有独立的用户空间，不允许共享，共享会产生访问异常**

我们从**高地址到低地址**来说明对应的内容：

- 命令行参数与环境变量：
	- 比如写c语言程序时的`main(int argc, char* argv[])`，后面的`argv`就是命令行参数
	- 环境变量就是用env查看的那个环境变量
- 进程栈：大概也许就是栈区空间吧
- Library库：需要有执行权限，进程运行的时候，那些函数功能的实现都保存在库中
- 堆：堆区空间
- BSS：未初始化的全局资源
- DATA：已初始化的全局资源
- TEXT：代码段
- NULL

### 页

操作系统分配资源的时候实际上并不是以字节为单位分配的，而是以页为单位分配的，大多数操作系统一页等于4096字节（4K）

接下来一个例子：

让程序员开发一段代码，申请8192个字节的内存

1. ```c
	malloc(3000);
	malloc(5192);
	```

2. ```c
	malloc(8192)
	```

> 其中第一种写法的实现过程是这样的：
>
> 首先申请了3000字节内存，操作系统会先分配一页，然后锁定部分访问权限，保证分配的是3000字节
>
> 然后检查页面的使用情况，再分配一个页面

> 第二种写法：
>
> 操作系统直接分配了两页的内存

#### 页的权限

每个页都有4重权限：

1. PROT_READ：只读
2. PROT_WRITE：只写
3. PROT_EXEC：执行
4. PROT_NONE：无权限

#### 虚拟内存间接寻页

一页有4096字节，一个指针占用4个字节，于是可以分出1024个指针，也就是能指向1024个页面，这就是一级间接寻页

以此类推，三级间接寻页最高的寻址范围为GB，32位系统最高支持**三级间接寻页**

64位系统就支持最大四级寻页，寻址范围为TB

## 进程状态

- 就绪态：进程处于就绪队列中，随时等待被分配时间片，然后运行
- R 运行态：进程正在运行
- T 挂起态：进程运行的过程中被挂起，交换到了外存，不会被干扰中断
- S 睡眠态：进程还在内存中，可以被干扰中断
- Orphan 孤儿态
- Zombie 僵尸太
- 终止态

### 睡眠态与挂起态的区别

挂起态进程由于被交换到了外存，于是只能被唤醒操作唤醒，而无法被其他方式中断

睡眠态进程还在内存中，所以可以被强制中断

### 状态转换

- 只有就绪态才能和运行态互相转换，其他状态都不能直接到运行态
- 运行态可以变成其他任何状态
- 任何状态都可以直接变成终止态
- 挂起态和睡眠态只能先转换到就绪态才能在之后变成运行态

## 用户层与内核层

用户层与内核层指的是不同访问级别的CPU，系统调用引发的权限转换其实就是CPU权限切换

每当执行一次系统函数都会触发一次系统调用System_call

`printf("hello"); // 用户层接口，系统提供的API函数，开发者可以调用这些函数完成一些特定的任务，例如将数据显示在显示器中`

调用完该函数后，系统调用触发权限转换，由用户层转换到了内核层

`System_print("hello")`执行系统层函数

随后又转换到了驱动层

`hd_printf("hello")`调用了驱动层函数

### 三种访问可以触发层级转换：

1. 系统调用，调用系统函数
2. 软件中断（int 0x80），时间片耗尽触发软中断
3. 异常触发层级转换

# 进程原语

Linux操作系统提供的用于进程开发的一系列函数接口 process_api

## fork

`pid_t fork(void);`返回值为`pid_t`

一般父进程可以通过fork函数创建一个子进程

父进程和子进程之间存在继承机制，任务或数据可以继承给子进程

**注意：子进程并不会执行fork方法，不然就一直不断创建了**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


int main() {
        pid_t pid;
        pid = fork(); // 子进程未执行fork

        printf("printf 01...\n");
        printf("printf 02...\n");
        while (1);

        return 0;
}
```

> 输出了4个printf

## execl

## wait

## waitpid

