# 线程安全

多线程在共享访问全局资源（全局变量，文件，数据库，数据结构）时，会产生冲突，导致数据异常，需要用到互斥访问（锁技术）

# 线程同步

多线程的鞋头配合，开发者控制线程何时执行何时应该挂起等待（条件变量，信号量）

# 互斥锁

只有一个锁，当任意线程申请并获得了该锁后，其他线程再申请就要等待了，一般在操作全局变量或共享资源的时候上锁

## 相关函数

> 变量lock是互斥锁类型的变量
>
> ```c
> pthread_mutex_t lock;
> ```

### 初始化互斥锁

```c
pthread_mutex_init(&lock, NULL);
```

### 销毁互斥锁

```c
pthread_mutex_destroy(&lock);
```

### 上锁

```c
pthread_mutex_lock(&lock);
```

### 解锁

```c
pthread_mutex_unlock(&lock);
```

### 非阻塞上锁

```c
pthread_mutex_trylock();
```

## 实践

```c
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

int cnt;
pthread_mutex_t lock;

void* thread(void* arg) {
	int t;
	for (int i = 0; i < 5000; ++i) {
		pthread_mutex_lock(&lock);
		t = cnt;
		printf("cnt = %d\n", ++t);
		cnt = t;
		pthread_mutex_unlock(&lock);
	}
}

int main() {
	pthread_t tids[2];
	pthread_mutex_init(&lock, NULL);
	for (int i = 0; i < 2; ++i) {
		pthread_create(&tids[i], NULL, thread, NULL);
	}
	while (1) sleep(1);
	pthread_mutex_destory(&lock);
	return 0;
}
```

# 读写锁

互斥锁的占用导致资源的利用率较低，只允许一个线程占用，读写访问资源

读写锁支持`读共享，写独占，读写互斥`，只有一个线程可以利用写锁修改数据，多个线程可以利用读锁读取数据，相比互斥锁提高资源使用频率

- 一把写锁（独占）：只有一个线程可以占用，其他线程等待使用
- N把读锁：多个线程可以一起共享使用，读锁如果耗尽，新线程要等待使用

## 相关函数

> 其中lock是读写锁类型的变量
>
> ```c
> pthread_rwlock_t lock;
> ```

### 初始化

```c
pthread_rwlock_init(&lock, NULL);
```

### 释放

```c
pthread_rwlock_destory(&lock);
```

### 上读锁

```c
pthread_rwlock_rdlock(&lock);
```

### 上写锁

```c
pthread_rwlock_wrlock(&lock);
```

### 解锁（读写都可以解除）

```c
pthread_rwlock_unlock(&lock);
```

## 实践

```c
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <sys/fcntl.h>

int cnt = 0;
pthread_rwlock_t lock;

void* rd(void* arg) {
	int t;
	while (1) {
		pthread_rwlock_rdlock(&lock);
		t = cnt;
		printf("read thread 0x%x, cnt = %d\n", (unsigned int)pthread_self(), t);
		pthread_rwlock_unlock(&lock);
		sleep(1);
	}
}

void* wr(void* arg) {
	int t;
	while (1) {
		pthread_rwlock_wrlock(&lock);
		t = cnt;
		printf("write thread 0x%x, cnt = %d\n", (unsigned int)pthread_self(), ++t);
		cnt = t;
		pthread_rwlock_unlock(&lock);
		sleep(1);
	}
}

int main() {
	pthread_t tid[8];
	int i = 0;
	for (i = 0; i < 3; ++i) {
		pthread_create(&tid[i], NULL, wr, NULL);
	}
	for (; i < 8; ++i) {
		pthread_create(&tid[i], NULL, rd, NULL);
	}
	while (1) sleep(1);
	pthread_rwlock_destroy(&lock);
	return 0;
}
```



